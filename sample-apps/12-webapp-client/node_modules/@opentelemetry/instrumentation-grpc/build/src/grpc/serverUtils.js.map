{"version":3,"file":"serverUtils.js","sourceRoot":"","sources":["../../../src/grpc/serverUtils.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type * as grpcTypes from 'grpc';\nimport { SendUnaryDataCallback, ServerCallWithMeta } from './types';\nimport { GrpcNativeInstrumentation } from './';\nimport { context, Span, SpanStatusCode } from '@opentelemetry/api';\nimport {\n  _grpcStatusCodeToOpenTelemetryStatusCode,\n  _grpcStatusCodeToSpanStatus,\n  _methodIsIgnored,\n} from '../utils';\nimport { AttributeNames } from '../enums/AttributeNames';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\n\nexport const clientStreamAndUnaryHandler = function <RequestType, ResponseType>(\n  grpcClient: typeof grpcTypes,\n  span: Span,\n  call: ServerCallWithMeta,\n  callback: SendUnaryDataCallback,\n  original:\n    | grpcTypes.handleCall<RequestType, ResponseType>\n    | grpcTypes.ClientReadableStream<RequestType>,\n  self: {}\n) {\n  function patchedCallback(\n    err: grpcTypes.ServiceError,\n    value: any,\n    trailer: grpcTypes.Metadata,\n    flags: grpcTypes.writeFlags\n  ) {\n    if (err) {\n      if (err.code) {\n        span.setStatus({\n          code: _grpcStatusCodeToOpenTelemetryStatusCode(err.code),\n          message: err.message,\n        });\n        span.setAttribute(\n          SemanticAttributes.RPC_GRPC_STATUS_CODE,\n          err.code.toString()\n        );\n      }\n      span.setAttributes({\n        [AttributeNames.GRPC_ERROR_NAME]: err.name,\n        [AttributeNames.GRPC_ERROR_MESSAGE]: err.message,\n      });\n    } else {\n      span.setStatus({ code: SpanStatusCode.UNSET });\n      span.setAttribute(\n        SemanticAttributes.RPC_GRPC_STATUS_CODE,\n        grpcClient.status.OK.toString()\n      );\n    }\n    span.addEvent('received');\n\n    // end the span\n    span.end();\n    return callback(err, value, trailer, flags);\n  }\n\n  context.bind(context.active(), call);\n  return (original as Function).call(self, call, patchedCallback);\n};\n\nexport const serverStreamAndBidiHandler = function <RequestType, ResponseType>(\n  span: Span,\n  call: ServerCallWithMeta,\n  original: grpcTypes.handleCall<RequestType, ResponseType>,\n  self: {}\n) {\n  let spanEnded = false;\n  const endSpan = () => {\n    if (!spanEnded) {\n      spanEnded = true;\n      span.end();\n    }\n  };\n\n  context.bind(context.active(), call);\n  call.on('finish', () => {\n    span.setStatus(_grpcStatusCodeToSpanStatus(call.status.code));\n    span.setAttribute(\n      SemanticAttributes.RPC_GRPC_STATUS_CODE,\n      call.status.code.toString()\n    );\n\n    // if there is an error, span will be ended on error event, otherwise end it here\n    if (call.status.code === 0) {\n      span.addEvent('finished');\n      endSpan();\n    }\n  });\n\n  call.on('error', (err: grpcTypes.ServiceError) => {\n    span.setStatus({\n      code: _grpcStatusCodeToOpenTelemetryStatusCode(err.code),\n      message: err.message,\n    });\n    span.addEvent('finished with error');\n    span.setAttributes({\n      [AttributeNames.GRPC_ERROR_NAME]: err.name,\n      [AttributeNames.GRPC_ERROR_MESSAGE]: err.message,\n    });\n    endSpan();\n  });\n\n  return (original as any).call(self, call);\n};\n\n/**\n * Returns true if the server call should not be traced.\n */\nexport const shouldNotTraceServerCall = function (\n  this: GrpcNativeInstrumentation,\n  call: ServerCallWithMeta,\n  name: string\n): boolean {\n  const parsedName = name.split('/');\n  return _methodIsIgnored(\n    parsedName[parsedName.length - 1] || name,\n    this.getConfig().ignoreGrpcMethods\n  );\n};\n"]}