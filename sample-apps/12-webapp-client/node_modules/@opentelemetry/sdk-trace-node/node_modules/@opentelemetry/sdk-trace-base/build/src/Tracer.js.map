{"version":3,"file":"Tracer.js","sourceRoot":"","sources":["../../src/Tracer.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  IdGenerator,\n  InstrumentationLibrary,\n  RandomIdGenerator,\n  sanitizeAttributes,\n  isTracingSuppressed,\n} from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport { BasicTracerProvider } from './BasicTracerProvider';\nimport { Span } from './Span';\nimport { GeneralLimits, SpanLimits, TracerConfig } from './types';\nimport { mergeConfig } from './utility';\nimport { SpanProcessor } from './SpanProcessor';\n\n/**\n * This class represents a basic tracer.\n */\nexport class Tracer implements api.Tracer {\n  private readonly _sampler: api.Sampler;\n  private readonly _generalLimits: GeneralLimits;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _idGenerator: IdGenerator;\n  readonly resource: Resource;\n  readonly instrumentationLibrary: InstrumentationLibrary;\n\n  /**\n   * Constructs a new Tracer instance.\n   */\n  constructor(\n    instrumentationLibrary: InstrumentationLibrary,\n    config: TracerConfig,\n    private _tracerProvider: BasicTracerProvider\n  ) {\n    const localConfig = mergeConfig(config);\n    this._sampler = localConfig.sampler;\n    this._generalLimits = localConfig.generalLimits;\n    this._spanLimits = localConfig.spanLimits;\n    this._idGenerator = config.idGenerator || new RandomIdGenerator();\n    this.resource = _tracerProvider.resource;\n    this.instrumentationLibrary = instrumentationLibrary;\n  }\n\n  /**\n   * Starts a new Span or returns the default NoopSpan based on the sampling\n   * decision.\n   */\n  startSpan(\n    name: string,\n    options: api.SpanOptions = {},\n    context = api.context.active()\n  ): api.Span {\n    if (isTracingSuppressed(context)) {\n      api.diag.debug('Instrumentation suppressed, returning Noop Span');\n      return api.trace.wrapSpanContext(api.INVALID_SPAN_CONTEXT);\n    }\n\n    // remove span from context in case a root span is requested via options\n    if (options.root) {\n      context = api.trace.deleteSpan(context);\n    }\n\n    const parentSpanContext = api.trace.getSpanContext(context);\n    const spanId = this._idGenerator.generateSpanId();\n    let traceId;\n    let traceState;\n    let parentSpanId;\n    if (!parentSpanContext || !api.trace.isSpanContextValid(parentSpanContext)) {\n      // New root span.\n      traceId = this._idGenerator.generateTraceId();\n    } else {\n      // New child span.\n      traceId = parentSpanContext.traceId;\n      traceState = parentSpanContext.traceState;\n      parentSpanId = parentSpanContext.spanId;\n    }\n\n    const spanKind = options.kind ?? api.SpanKind.INTERNAL;\n    const links = (options.links ?? []).map(link => {\n      return {\n        context: link.context,\n        attributes: sanitizeAttributes(link.attributes),\n      };\n    });\n    const attributes = sanitizeAttributes(options.attributes);\n    // make sampling decision\n    const samplingResult = this._sampler.shouldSample(\n      context,\n      traceId,\n      name,\n      spanKind,\n      attributes,\n      links\n    );\n\n    const traceFlags =\n      samplingResult.decision === api.SamplingDecision.RECORD_AND_SAMPLED\n        ? api.TraceFlags.SAMPLED\n        : api.TraceFlags.NONE;\n    const spanContext = { traceId, spanId, traceFlags, traceState };\n    if (samplingResult.decision === api.SamplingDecision.NOT_RECORD) {\n      api.diag.debug('Recording is off, propagating context in a non-recording span');\n      return api.trace.wrapSpanContext(spanContext);\n    }\n\n    const span = new Span(\n      this,\n      context,\n      name,\n      spanContext,\n      spanKind,\n      parentSpanId,\n      links,\n      options.startTime\n    );\n    // Set initial span attributes. The attributes object may have been mutated\n    // by the sampler, so we sanitize the merged attributes before setting them.\n    const initAttributes = sanitizeAttributes(Object.assign(attributes, samplingResult.attributes));\n    span.setAttributes(initAttributes);\n    return span;\n  }\n\n  /**\n   * Starts a new {@link Span} and calls the given function passing it the\n   * created span as first argument.\n   * Additionally the new span gets set in context and this context is activated\n   * for the duration of the function call.\n   *\n   * @param name The name of the span\n   * @param [options] SpanOptions used for span creation\n   * @param [context] Context to use to extract parent\n   * @param fn function called in the context of the span and receives the newly created span as an argument\n   * @returns return value of fn\n   * @example\n   *   const something = tracer.startActiveSpan('op', span => {\n   *     try {\n   *       do some work\n   *       span.setStatus({code: SpanStatusCode.OK});\n   *       return something;\n   *     } catch (err) {\n   *       span.setStatus({\n   *         code: SpanStatusCode.ERROR,\n   *         message: err.message,\n   *       });\n   *       throw err;\n   *     } finally {\n   *       span.end();\n   *     }\n   *   });\n   * @example\n   *   const span = tracer.startActiveSpan('op', span => {\n   *     try {\n   *       do some work\n   *       return span;\n   *     } catch (err) {\n   *       span.setStatus({\n   *         code: SpanStatusCode.ERROR,\n   *         message: err.message,\n   *       });\n   *       throw err;\n   *     }\n   *   });\n   *   do some more work\n   *   span.end();\n   */\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    opts: api.SpanOptions,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    opts: api.SpanOptions,\n    ctx: api.Context,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: api.Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | api.SpanOptions,\n    arg3?: F | api.Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: api.SpanOptions | undefined;\n    let ctx: api.Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as api.SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as api.SpanOptions | undefined;\n      ctx = arg3 as api.Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? api.context.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = api.trace.setSpan(parentContext, span);\n\n    return api.context.with(contextWithSpanSet, fn, undefined, span);\n  }\n\n  /** Returns the active {@link GeneralLimits}. */\n  getGeneralLimits(): GeneralLimits {\n    return this._generalLimits;\n  }\n\n  /** Returns the active {@link SpanLimits}. */\n  getSpanLimits(): SpanLimits {\n    return this._spanLimits;\n  }\n\n  getActiveSpanProcessor(): SpanProcessor {\n    return this._tracerProvider.getActiveSpanProcessor();\n  }\n}\n"]}