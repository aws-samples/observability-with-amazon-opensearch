{"version":3,"file":"Span.js","sourceRoot":"","sources":["../../src/Span.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG;AAEH,OAAO,KAAK,GAAG,MAAM,oBAAoB,CAAC;AAC1C,OAAO,EACL,gBAAgB,EAChB,MAAM,EACN,cAAc,EAEd,WAAW,EACX,iBAAiB,EACjB,kBAAkB,GACnB,MAAM,qBAAqB,CAAC;AAE7B,OAAO,EAAE,kBAAkB,EAAE,MAAM,qCAAqC,CAAC;AAOzE,OAAO,EAAE,kBAAkB,EAAE,MAAM,SAAS,CAAC;AAE7C;;GAEG;AACH,MAAM,OAAO,IAAI;IAuBf,sCAAsC;IACtC,YACE,YAAoB,EACpB,OAAgB,EAChB,QAAgB,EAChB,WAA4B,EAC5B,IAAkB,EAClB,YAAqB,EACrB,QAAoB,EAAE,EACtB,YAA2B,MAAM,EAAE;QA1B5B,eAAU,GAAuB,EAAE,CAAC;QACpC,UAAK,GAAe,EAAE,CAAC;QACvB,WAAM,GAAiB,EAAE,CAAC;QAKnC,WAAM,GAAmB;YACvB,IAAI,EAAE,GAAG,CAAC,cAAc,CAAC,KAAK;SAC/B,CAAC;QACF,YAAO,GAAe,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;QACrB,WAAM,GAAG,KAAK,CAAC;QACf,cAAS,GAAe,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAgBvC,IAAI,CAAC,IAAI,GAAG,QAAQ,CAAC;QACrB,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;QAChC,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,SAAS,GAAG,iBAAiB,CAAC,SAAS,CAAC,CAAC;QAC9C,IAAI,CAAC,QAAQ,GAAG,YAAY,CAAC,QAAQ,CAAC;QACtC,IAAI,CAAC,sBAAsB,GAAG,YAAY,CAAC,sBAAsB,CAAC;QAClE,IAAI,CAAC,WAAW,GAAG,YAAY,CAAC,aAAa,EAAE,CAAC;QAChD,IAAI,CAAC,cAAc,GAAG,YAAY,CAAC,sBAAsB,EAAE,CAAC;QAC5D,IAAI,CAAC,cAAc,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QAC3C,IAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC,WAAW,CAAC,yBAAyB,IAAI,CAAC,CAAC;IACpF,CAAC;IAED,WAAW;QACT,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;IAGD,YAAY,CAAC,GAAW,EAAE,KAAc;QACtC,IAAI,KAAK,IAAI,IAAI,IAAI,IAAI,CAAC,YAAY,EAAE;YAAE,OAAO,IAAI,CAAC;QACtD,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE;YACpB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,0BAA0B,GAAG,EAAE,CAAC,CAAC;YAC/C,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,gBAAgB,CAAC,KAAK,CAAC,EAAE;YAC5B,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,wCAAwC,GAAG,EAAE,CAAC,CAAC;YAC7D,OAAO,IAAI,CAAC;SACb;QAED,IACE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,MAAM;YACjC,IAAI,CAAC,WAAW,CAAC,mBAAoB;YACvC,CAAC,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,GAAG,CAAC,EAC3D;YACA,OAAO,IAAI,CAAC;SACb;QACD,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,CAAC;QACnD,OAAO,IAAI,CAAC;IACd,CAAC;IAED,aAAa,CAAC,UAA8B;QAC1C,KAAK,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;YAC/C,IAAI,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;SACzB;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;;OAMG;IACH,QAAQ,CACN,IAAY,EACZ,qBAA0D,EAC1D,SAAyB;QAEzB,IAAI,IAAI,CAAC,YAAY,EAAE;YAAE,OAAO,IAAI,CAAC;QACrC,IAAI,IAAI,CAAC,WAAW,CAAC,eAAe,KAAK,CAAC,EAAE;YAC1C,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,oBAAoB,CAAC,CAAC;YACpC,OAAO,IAAI,CAAC;SACb;QACD,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,IAAI,IAAI,CAAC,WAAW,CAAC,eAAgB,EAAE;YAC3D,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC;YACxC,IAAI,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;SACrB;QACD,IAAI,WAAW,CAAC,qBAAqB,CAAC,EAAE;YACtC,IAAI,OAAO,SAAS,KAAK,WAAW,EAAE;gBACpC,SAAS,GAAG,qBAAsC,CAAC;aACpD;YACD,qBAAqB,GAAG,SAAS,CAAC;SACnC;QACD,IAAI,OAAO,SAAS,KAAK,WAAW,EAAE;YACpC,SAAS,GAAG,MAAM,EAAE,CAAC;SACtB;QAED,MAAM,UAAU,GAAG,kBAAkB,CAAC,qBAAqB,CAAC,CAAC;QAC7D,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;YACf,IAAI;YACJ,UAAU;YACV,IAAI,EAAE,iBAAiB,CAAC,SAAS,CAAC;SACnC,CAAC,CAAC;QACH,OAAO,IAAI,CAAC;IACd,CAAC;IAED,SAAS,CAAC,MAAsB;QAC9B,IAAI,IAAI,CAAC,YAAY,EAAE;YAAE,OAAO,IAAI,CAAC;QACrC,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,OAAO,IAAI,CAAC;IACd,CAAC;IAED,UAAU,CAAC,IAAY;QACrB,IAAI,IAAI,CAAC,YAAY,EAAE;YAAE,OAAO,IAAI,CAAC;QACrC,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;QACjB,OAAO,IAAI,CAAC;IACd,CAAC;IAED,GAAG,CAAC,UAAyB,MAAM,EAAE;QACnC,IAAI,IAAI,CAAC,YAAY,EAAE,EAAE;YACvB,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,yCAAyC,CAAC,CAAC;YAC1D,OAAO;SACR;QACD,IAAI,CAAC,MAAM,GAAG,IAAI,CAAC;QACnB,IAAI,CAAC,OAAO,GAAG,iBAAiB,CAAC,OAAO,CAAC,CAAC;QAE1C,IAAI,CAAC,SAAS,GAAG,cAAc,CAAC,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,OAAO,CAAC,CAAC;QAC9D,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;YACzB,GAAG,CAAC,IAAI,CAAC,IAAI,CACX,sDAAsD,EACtD,IAAI,CAAC,SAAS,EACd,IAAI,CAAC,OAAO,CACb,CAAC;SACH;QAED,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAClC,CAAC;IAED,WAAW;QACT,OAAO,IAAI,CAAC,MAAM,KAAK,KAAK,CAAC;IAC/B,CAAC;IAED,eAAe,CAAC,SAAwB,EAAE,OAAsB,MAAM,EAAE;QACtE,MAAM,UAAU,GAAuB,EAAE,CAAC;QAC1C,IAAI,OAAO,SAAS,KAAK,QAAQ,EAAE;YACjC,UAAU,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,GAAG,SAAS,CAAC;SAC9D;aAAM,IAAI,SAAS,EAAE;YACpB,IAAI,SAAS,CAAC,IAAI,EAAE;gBAClB,UAAU,CACR,kBAAkB,CAAC,cAAc,CAClC,GAAG,SAAS,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC;aAC/B;iBAAM,IAAI,SAAS,CAAC,IAAI,EAAE;gBACzB,UAAU,CAAC,kBAAkB,CAAC,cAAc,CAAC,GAAG,SAAS,CAAC,IAAI,CAAC;aAChE;YACD,IAAI,SAAS,CAAC,OAAO,EAAE;gBACrB,UAAU,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,GAAG,SAAS,CAAC,OAAO,CAAC;aACtE;YACD,IAAI,SAAS,CAAC,KAAK,EAAE;gBACnB,UAAU,CAAC,kBAAkB,CAAC,oBAAoB,CAAC,GAAG,SAAS,CAAC,KAAK,CAAC;aACvE;SACF;QAED,2CAA2C;QAC3C,IACE,UAAU,CAAC,kBAAkB,CAAC,cAAc,CAAC;YAC7C,UAAU,CAAC,kBAAkB,CAAC,iBAAiB,CAAC,EAChD;YACA,IAAI,CAAC,QAAQ,CAAC,kBAAkB,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;SACrD;aAAM;YACL,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,iCAAiC,SAAS,EAAE,CAAC,CAAC;SAC7D;IACH,CAAC;IAED,IAAI,QAAQ;QACV,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB,CAAC;IAED,IAAI,KAAK;QACP,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IAEO,YAAY;QAClB,IAAI,IAAI,CAAC,MAAM,EAAE;YACf,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,yDAAyD,IAAI,CAAC,YAAY,CAAC,OAAO,aAAa,IAAI,CAAC,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC;SAC3I;QACD,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IAED,uDAAuD;IACvD,yDAAyD;IACzD,iDAAiD;IACzC,oBAAoB,CAAC,KAAa,EAAE,KAAa;QACvD,IAAI,KAAK,CAAC,MAAM,IAAI,KAAK,EAAE;YACzB,OAAO,KAAK,CAAC;SACd;QACD,OAAO,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC;IAChC,CAAC;IAED;;;;;;;;;;;OAWG;IACK,eAAe,CAAC,KAAyB;QAC/C,MAAM,KAAK,GAAG,IAAI,CAAC,0BAA0B,CAAC;QAC9C,cAAc;QACd,IAAI,KAAK,IAAI,CAAC,EAAE;YACd,kDAAkD;YAClD,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,+CAA+C,KAAK,EAAE,CAAC,CAAC;YACtE,OAAO,KAAK,CAAC;SACd;QAED,SAAS;QACT,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;YAC7B,OAAO,IAAI,CAAC,oBAAoB,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;SAChD;QAED,mBAAmB;QACnB,IAAI,KAAK,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE;YACxB,OAAQ,KAAY,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,OAAO,GAAG,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,oBAAoB,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;SACxG;QAED,mDAAmD;QACnD,OAAO,KAAK,CAAC;IACf,CAAC;CACF","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  isAttributeValue,\n  hrTime,\n  hrTimeDuration,\n  InstrumentationLibrary,\n  isTimeInput,\n  timeInputToHrTime,\n  sanitizeAttributes,\n} from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\nimport { SemanticAttributes } from '@opentelemetry/semantic-conventions';\nimport { ReadableSpan } from './export/ReadableSpan';\nimport { TimedEvent } from './TimedEvent';\nimport { Tracer } from './Tracer';\nimport { SpanProcessor } from './SpanProcessor';\nimport { SpanLimits } from './types';\nimport { SpanAttributeValue, Context } from '@opentelemetry/api';\nimport { ExceptionEventName } from './enums';\n\n/**\n * This class represents a span.\n */\nexport class Span implements api.Span, ReadableSpan {\n  // Below properties are included to implement ReadableSpan for export\n  // purposes but are not intended to be written-to directly.\n  private readonly _spanContext: api.SpanContext;\n  readonly kind: api.SpanKind;\n  readonly parentSpanId?: string;\n  readonly attributes: api.SpanAttributes = {};\n  readonly links: api.Link[] = [];\n  readonly events: TimedEvent[] = [];\n  readonly startTime: api.HrTime;\n  readonly resource: Resource;\n  readonly instrumentationLibrary: InstrumentationLibrary;\n  name: string;\n  status: api.SpanStatus = {\n    code: api.SpanStatusCode.UNSET,\n  };\n  endTime: api.HrTime = [0, 0];\n  private _ended = false;\n  private _duration: api.HrTime = [-1, -1];\n  private readonly _spanProcessor: SpanProcessor;\n  private readonly _spanLimits: SpanLimits;\n  private readonly _attributeValueLengthLimit: number;\n\n  /** Constructs a new Span instance. */\n  constructor(\n    parentTracer: Tracer,\n    context: Context,\n    spanName: string,\n    spanContext: api.SpanContext,\n    kind: api.SpanKind,\n    parentSpanId?: string,\n    links: api.Link[] = [],\n    startTime: api.TimeInput = hrTime()\n  ) {\n    this.name = spanName;\n    this._spanContext = spanContext;\n    this.parentSpanId = parentSpanId;\n    this.kind = kind;\n    this.links = links;\n    this.startTime = timeInputToHrTime(startTime);\n    this.resource = parentTracer.resource;\n    this.instrumentationLibrary = parentTracer.instrumentationLibrary;\n    this._spanLimits = parentTracer.getSpanLimits();\n    this._spanProcessor = parentTracer.getActiveSpanProcessor();\n    this._spanProcessor.onStart(this, context);\n    this._attributeValueLengthLimit = this._spanLimits.attributeValueLengthLimit || 0;\n  }\n\n  spanContext(): api.SpanContext {\n    return this._spanContext;\n  }\n\n  setAttribute(key: string, value?: SpanAttributeValue): this;\n  setAttribute(key: string, value: unknown): this {\n    if (value == null || this._isSpanEnded()) return this;\n    if (key.length === 0) {\n      api.diag.warn(`Invalid attribute key: ${key}`);\n      return this;\n    }\n    if (!isAttributeValue(value)) {\n      api.diag.warn(`Invalid attribute value set for key: ${key}`);\n      return this;\n    }\n\n    if (\n      Object.keys(this.attributes).length >=\n        this._spanLimits.attributeCountLimit! &&\n      !Object.prototype.hasOwnProperty.call(this.attributes, key)\n    ) {\n      return this;\n    }\n    this.attributes[key] = this._truncateToSize(value);\n    return this;\n  }\n\n  setAttributes(attributes: api.SpanAttributes): this {\n    for (const [k, v] of Object.entries(attributes)) {\n      this.setAttribute(k, v);\n    }\n    return this;\n  }\n\n  /**\n   *\n   * @param name Span Name\n   * @param [attributesOrStartTime] Span attributes or start time\n   *     if type is {@type TimeInput} and 3rd param is undefined\n   * @param [startTime] Specified start time for the event\n   */\n  addEvent(\n    name: string,\n    attributesOrStartTime?: api.SpanAttributes | api.TimeInput,\n    startTime?: api.TimeInput\n  ): this {\n    if (this._isSpanEnded()) return this;\n    if (this._spanLimits.eventCountLimit === 0) {\n      api.diag.warn('No events allowed.');\n      return this;\n    }\n    if (this.events.length >= this._spanLimits.eventCountLimit!) {\n      api.diag.warn('Dropping extra events.');\n      this.events.shift();\n    }\n    if (isTimeInput(attributesOrStartTime)) {\n      if (typeof startTime === 'undefined') {\n        startTime = attributesOrStartTime as api.TimeInput;\n      }\n      attributesOrStartTime = undefined;\n    }\n    if (typeof startTime === 'undefined') {\n      startTime = hrTime();\n    }\n\n    const attributes = sanitizeAttributes(attributesOrStartTime);\n    this.events.push({\n      name,\n      attributes,\n      time: timeInputToHrTime(startTime),\n    });\n    return this;\n  }\n\n  setStatus(status: api.SpanStatus): this {\n    if (this._isSpanEnded()) return this;\n    this.status = status;\n    return this;\n  }\n\n  updateName(name: string): this {\n    if (this._isSpanEnded()) return this;\n    this.name = name;\n    return this;\n  }\n\n  end(endTime: api.TimeInput = hrTime()): void {\n    if (this._isSpanEnded()) {\n      api.diag.error('You can only call end() on a span once.');\n      return;\n    }\n    this._ended = true;\n    this.endTime = timeInputToHrTime(endTime);\n\n    this._duration = hrTimeDuration(this.startTime, this.endTime);\n    if (this._duration[0] < 0) {\n      api.diag.warn(\n        'Inconsistent start and end time, startTime > endTime',\n        this.startTime,\n        this.endTime\n      );\n    }\n\n    this._spanProcessor.onEnd(this);\n  }\n\n  isRecording(): boolean {\n    return this._ended === false;\n  }\n\n  recordException(exception: api.Exception, time: api.TimeInput = hrTime()): void {\n    const attributes: api.SpanAttributes = {};\n    if (typeof exception === 'string') {\n      attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception;\n    } else if (exception) {\n      if (exception.code) {\n        attributes[\n          SemanticAttributes.EXCEPTION_TYPE\n        ] = exception.code.toString();\n      } else if (exception.name) {\n        attributes[SemanticAttributes.EXCEPTION_TYPE] = exception.name;\n      }\n      if (exception.message) {\n        attributes[SemanticAttributes.EXCEPTION_MESSAGE] = exception.message;\n      }\n      if (exception.stack) {\n        attributes[SemanticAttributes.EXCEPTION_STACKTRACE] = exception.stack;\n      }\n    }\n\n    // these are minimum requirements from spec\n    if (\n      attributes[SemanticAttributes.EXCEPTION_TYPE] ||\n      attributes[SemanticAttributes.EXCEPTION_MESSAGE]\n    ) {\n      this.addEvent(ExceptionEventName, attributes, time);\n    } else {\n      api.diag.warn(`Failed to record an exception ${exception}`);\n    }\n  }\n\n  get duration(): api.HrTime {\n    return this._duration;\n  }\n\n  get ended(): boolean {\n    return this._ended;\n  }\n\n  private _isSpanEnded(): boolean {\n    if (this._ended) {\n      api.diag.warn(`Can not execute the operation on ended Span {traceId: ${this._spanContext.traceId}, spanId: ${this._spanContext.spanId}}`);\n    }\n    return this._ended;\n  }\n\n  // Utility function to truncate given value within size\n  // for value type of string, will truncate to given limit\n  // for type of non-string, will return same value\n  private _truncateToLimitUtil(value: string, limit: number): string {\n    if (value.length <= limit) {\n      return value;\n    }\n    return value.substr(0, limit);\n  }\n\n  /**\n   * If the given attribute value is of type string and has more characters than given {@code attributeValueLengthLimit} then\n   * return string with trucated to {@code attributeValueLengthLimit} characters\n   *\n   * If the given attribute value is array of strings then\n   * return new array of strings with each element truncated to {@code attributeValueLengthLimit} characters\n   *\n   * Otherwise return same Attribute {@code value}\n   *\n   * @param value Attribute value\n   * @returns truncated attribute value if required, otherwise same value\n   */\n  private _truncateToSize(value: SpanAttributeValue): SpanAttributeValue {\n    const limit = this._attributeValueLengthLimit;\n    // Check limit\n    if (limit <= 0) {\n      // Negative values are invalid, so do not truncate\n      api.diag.warn(`Attribute value limit must be positive, got ${limit}`);\n      return value;\n    }\n\n    // String\n    if (typeof value === 'string') {\n      return this._truncateToLimitUtil(value, limit);\n    }\n\n    // Array of strings\n    if (Array.isArray(value)) {\n      return (value as []).map(val => typeof val === 'string' ? this._truncateToLimitUtil(val, limit) : val);\n    }\n\n    // Other types, no need to apply value length limit\n    return value;\n  }\n}\n"]}