/// <reference types="node" />
import { InstrumentationBase, InstrumentationModuleDefinition } from '@opentelemetry/instrumentation';
import type * as amqp from 'amqplib';
import { AmqplibInstrumentationConfig } from './types';
import { InstrumentationConsumeChannel, InstrumentationPublishChannel } from './utils';
export declare class AmqplibInstrumentation extends InstrumentationBase<typeof amqp> {
    protected _config: AmqplibInstrumentationConfig;
    constructor(config?: AmqplibInstrumentationConfig);
    setConfig(config?: AmqplibInstrumentationConfig): void;
    protected init(): InstrumentationModuleDefinition<typeof amqp>;
    private patchConnect;
    private unpatchConnect;
    private patchChannelModel;
    private unpatchChannelModel;
    private getConnectPatch;
    private getChannelEmitPatch;
    private getAckAllPatch;
    private getAckPatch;
    protected getConsumePatch(moduleVersion: string | undefined, original: Function): (this: InstrumentationConsumeChannel, queue: string, onMessage: (msg: amqp.ConsumeMessage | null) => void, options?: amqp.Options.Consume | undefined) => Promise<amqp.Replies.Consume>;
    protected getConfirmedPublishPatch(moduleVersion: string | undefined, original: Function): (this: InstrumentationConsumeChannel, exchange: string, routingKey: string, content: Buffer, options?: amqp.Options.Publish | undefined, callback?: ((err: any, ok: amqp.Replies.Empty) => void) | undefined) => boolean;
    protected getPublishPatch(moduleVersion: string | undefined, original: Function): (this: InstrumentationPublishChannel, exchange: string, routingKey: string, content: Buffer, options?: amqp.Options.Publish | undefined) => boolean;
    private createPublishSpan;
    private endConsumerSpan;
    private endAllSpansOnChannel;
    private callConsumeEndHook;
    private checkConsumeTimeoutOnChannel;
}
//# sourceMappingURL=amqplib.d.ts.map