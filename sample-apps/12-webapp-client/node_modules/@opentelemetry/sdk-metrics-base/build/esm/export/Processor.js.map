{"version":3,"file":"Processor.js","sourceRoot":"","sources":["../../../src/export/Processor.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG;;;;;;;;;;;;;;;;AAEH,OAAO,KAAK,WAAW,MAAM,eAAe,CAAC;AAC7C,OAAO,EAEL,UAAU,GAGX,MAAM,SAAS,CAAC;AAEjB;;;;;;GAMG;AACH;IAAA;QACqB,cAAS,GAAG,IAAI,GAAG,EAAwB,CAAC;IAWjE,CAAC;IAHC,iCAAa,GAAb;QACE,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC,CAAC;IAC7C,CAAC;IACH,gBAAC;AAAD,CAAC,AAZD,IAYC;;AAED;;;GAGG;AACH;IAAwC,sCAAS;IAAjD;;IA4BA,CAAC;IA3BC,0CAAa,GAAb,UAAc,gBAAkC;QAC9C,QAAQ,gBAAgB,CAAC,UAAU,EAAE;YACnC,KAAK,UAAU,CAAC,OAAO,CAAC;YACxB,KAAK,UAAU,CAAC,eAAe;gBAC7B,OAAO,IAAI,WAAW,CAAC,aAAa,EAAE,CAAC;YAEzC,KAAK,UAAU,CAAC,YAAY,CAAC;YAC7B,KAAK,UAAU,CAAC,oBAAoB,CAAC;YACrC,KAAK,UAAU,CAAC,cAAc;gBAC5B,OAAO,IAAI,WAAW,CAAC,mBAAmB,EAAE,CAAC;YAE/C,KAAK,UAAU,CAAC,cAAc;gBAC5B,OAAO,IAAI,WAAW,CAAC,mBAAmB,CACxC,gBAAgB,CAAC,UAAU,IAAI,CAAC,QAAQ,CAAC,CAC1C,CAAC;YAEJ;gBACE,OAAO,IAAI,WAAW,CAAC,mBAAmB,EAAE,CAAC;SAChD;IACH,CAAC;IAED,oCAAO,GAAP,UAAQ,MAAoB;QAC1B,IAAM,MAAM,GAAG,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC;aACtC,GAAG,CAAC,UAAA,CAAC,IAAI,OAAG,CAAC,SAAI,MAAM,CAAC,MAAM,CAAC,CAAC,CAAG,EAA1B,CAA0B,CAAC;aACpC,IAAI,CAAC,GAAG,CAAC,CAAC;QACb,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,GAAG,MAAM,EAAE,MAAM,CAAC,CAAC;IAC9D,CAAC;IACH,yBAAC;AAAD,CAAC,AA5BD,CAAwC,SAAS,GA4BhD","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as aggregators from './aggregators';\nimport {\n  MetricRecord,\n  MetricKind,\n  Aggregator,\n  MetricDescriptor,\n} from './types';\n\n/**\n * Base class for all processor types.\n *\n * The processor is responsible for storing the aggregators and aggregated\n * values received from updates from metrics in the meter. The stored values\n * will be sent to an exporter for exporting.\n */\nexport abstract class Processor {\n  protected readonly _batchMap = new Map<string, MetricRecord>();\n\n  /** Returns an aggregator based off metric descriptor. */\n  abstract aggregatorFor(metricKind: MetricDescriptor): Aggregator;\n\n  /** Stores record information to be ready for exporting. */\n  abstract process(record: MetricRecord): void;\n\n  checkPointSet(): MetricRecord[] {\n    return Array.from(this._batchMap.values());\n  }\n}\n\n/**\n * Processor which retains all dimensions/labels. It accepts all records and\n * passes them for exporting.\n */\nexport class UngroupedProcessor extends Processor {\n  aggregatorFor(metricDescriptor: MetricDescriptor): Aggregator {\n    switch (metricDescriptor.metricKind) {\n      case MetricKind.COUNTER:\n      case MetricKind.UP_DOWN_COUNTER:\n        return new aggregators.SumAggregator();\n\n      case MetricKind.SUM_OBSERVER:\n      case MetricKind.UP_DOWN_SUM_OBSERVER:\n      case MetricKind.VALUE_OBSERVER:\n        return new aggregators.LastValueAggregator();\n\n      case MetricKind.VALUE_RECORDER:\n        return new aggregators.HistogramAggregator(\n          metricDescriptor.boundaries || [Infinity]\n        );\n\n      default:\n        return new aggregators.LastValueAggregator();\n    }\n  }\n\n  process(record: MetricRecord): void {\n    const labels = Object.keys(record.labels)\n      .map(k => `${k}=${record.labels[k]}`)\n      .join(',');\n    this._batchMap.set(record.descriptor.name + labels, record);\n  }\n}\n"]}