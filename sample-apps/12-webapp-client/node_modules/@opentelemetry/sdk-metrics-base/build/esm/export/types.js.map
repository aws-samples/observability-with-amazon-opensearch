{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../src/export/types.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG;AAWH,0BAA0B;AAC1B,MAAM,CAAN,IAAY,UAQX;AARD,WAAY,UAAU;IACpB,iDAAO,CAAA;IACP,iEAAe,CAAA;IACf,+DAAc,CAAA;IACd,2DAAY,CAAA;IACZ,2EAAoB,CAAA;IACpB,+DAAc,CAAA;IACd,+DAAc,CAAA;AAChB,CAAC,EARW,UAAU,KAAV,UAAU,QAQrB;AAED,MAAM,CAAC,IAAM,gBAAgB,GAAG,MAAM,CAAC,MAAM,CAAC,UAAU,CAAC,CAAC;AAE1D,8BAA8B;AAC9B,MAAM,CAAN,IAAY,cAIX;AAJD,WAAY,cAAc;IACxB,iDAAG,CAAA;IACH,+DAAU,CAAA;IACV,6DAAS,CAAA;AACX,CAAC,EAJW,cAAc,KAAd,cAAc,QAIzB","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HrTime } from '@opentelemetry/api';\nimport {\n  Labels,\n  AggregationTemporality,\n  ValueType,\n} from '@opentelemetry/api-metrics';\nimport { ExportResult, InstrumentationLibrary } from '@opentelemetry/core';\nimport { Resource } from '@opentelemetry/resources';\n\n/** The kind of metric. */\nexport enum MetricKind {\n  COUNTER,\n  UP_DOWN_COUNTER,\n  VALUE_RECORDER,\n  SUM_OBSERVER,\n  UP_DOWN_SUM_OBSERVER,\n  VALUE_OBSERVER,\n  BATCH_OBSERVER,\n}\n\nexport const MetricKindValues = Object.values(MetricKind);\n\n/** The kind of aggregator. */\nexport enum AggregatorKind {\n  SUM,\n  LAST_VALUE,\n  HISTOGRAM,\n}\n\n/** Sum returns an aggregated sum. */\nexport type Sum = number;\n\n/** LastValue returns last value. */\nexport type LastValue = number;\n\nexport interface Histogram {\n  /**\n   * Buckets are implemented using two different arrays:\n   *  - boundaries: contains every finite bucket boundary, which are inclusive lower bounds\n   *  - counts: contains event counts for each bucket\n   *\n   * Note that we'll always have n+1 buckets, where n is the number of boundaries.\n   * This is because we need to count events that are below the lowest boundary.\n   *\n   * Example: if we measure the values: [5, 30, 5, 40, 5, 15, 15, 15, 25]\n   *  with the boundaries [ 10, 20, 30 ], we will have the following state:\n   *\n   * buckets: {\n   *\tboundaries: [10, 20, 30],\n   *\tcounts: [3, 3, 1, 2],\n   * }\n   */\n  buckets: {\n    boundaries: number[];\n    counts: number[];\n  };\n  sum: number;\n  count: number;\n}\n\nexport type PointValueType = Sum | LastValue | Histogram;\n\nexport interface MetricRecord {\n  readonly descriptor: MetricDescriptor;\n  readonly labels: Labels;\n  readonly aggregator: Aggregator;\n  readonly aggregationTemporality: AggregationTemporality;\n  readonly resource: Resource;\n  readonly instrumentationLibrary: InstrumentationLibrary;\n}\n\nexport interface MetricDescriptor {\n  readonly name: string;\n  readonly description: string;\n  readonly unit: string;\n  readonly metricKind: MetricKind;\n  readonly valueType: ValueType;\n  readonly boundaries?: number[];\n}\n\n/**\n * Base interface that represents a metric exporter\n */\nexport interface MetricExporter {\n  /** Exports the list of a given {@link MetricRecord} */\n  export(\n    metrics: MetricRecord[],\n    resultCallback: (result: ExportResult) => void\n  ): void;\n\n  /** Stops the exporter. */\n  shutdown(): Promise<void>;\n}\n\n/**\n * Base interface for aggregators. Aggregators are responsible for holding\n * aggregated values and taking a snapshot of these values upon export.\n *\n * Use {@link Aggregator} instead of this BaseAggregator.\n */\ninterface BaseAggregator {\n  /** The kind of the aggregator. */\n  kind: AggregatorKind;\n\n  /** Updates the current with the new value. */\n  update(value: number): void;\n}\n\n/** SumAggregatorType aggregate values into a {@link Sum} point type. */\nexport interface SumAggregatorType extends BaseAggregator {\n  kind: AggregatorKind.SUM;\n\n  /** Returns snapshot of the current point (value with timestamp). */\n  toPoint(): Point<Sum>;\n}\n\n/**\n * LastValueAggregatorType aggregate values into a {@link LastValue} point\n * type.\n */\nexport interface LastValueAggregatorType extends BaseAggregator {\n  kind: AggregatorKind.LAST_VALUE;\n\n  /** Returns snapshot of the current point (value with timestamp). */\n  toPoint(): Point<LastValue>;\n}\n\n/**\n * HistogramAggregatorType aggregate values into a {@link Histogram} point\n * type.\n */\nexport interface HistogramAggregatorType extends BaseAggregator {\n  kind: AggregatorKind.HISTOGRAM;\n\n  /** Returns snapshot of the current point (value with timestamp). */\n  toPoint(): Point<Histogram>;\n}\n\nexport type Aggregator =\n  | SumAggregatorType\n  | LastValueAggregatorType\n  | HistogramAggregatorType;\n\n/**\n * Point represents a snapshot of aggregated values of aggregators.\n */\nexport interface Point<T extends PointValueType> {\n  value: T;\n  timestamp: HrTime;\n}\n"]}