{"version":3,"file":"transformMetrics.js","sourceRoot":"","sources":["../../src/transformMetrics.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanAttributes, HrTime } from '@opentelemetry/api';\nimport { Labels, ValueType } from '@opentelemetry/api-metrics';\nimport * as core from '@opentelemetry/core';\nimport {\n  AggregatorKind,\n  Histogram,\n  MetricKind,\n  MetricRecord,\n} from '@opentelemetry/sdk-metrics-base';\nimport { Resource } from '@opentelemetry/resources';\nimport { OTLPExporterBase } from './OTLPExporterBase';\nimport { toCollectorResource } from './transform';\nimport { OTLPExporterConfigBase, opentelemetryProto } from './types';\n\n/**\n * Converts labels\n * @param labels\n */\nexport function toCollectorLabels(\n  labels: Labels\n): opentelemetryProto.common.v1.StringKeyValue[] {\n  return Object.entries(labels).map(([key, value]) => {\n    return { key, value: String(value) };\n  });\n}\n\n/**\n * Given a MetricDescriptor, return its temporality in a compatible format with the collector\n * @param descriptor\n */\nexport function toAggregationTemporality(\n  metric: MetricRecord\n): opentelemetryProto.metrics.v1.AggregationTemporality {\n  if (metric.descriptor.metricKind === MetricKind.VALUE_OBSERVER) {\n    return opentelemetryProto.metrics.v1.AggregationTemporality\n      .AGGREGATION_TEMPORALITY_UNSPECIFIED;\n  }\n\n  return metric.aggregationTemporality;\n}\n\n/**\n * Returns an DataPoint which can have integers or doublle values\n * @param metric\n * @param startTime\n */\nexport function toDataPoint(\n  metric: MetricRecord,\n  startTime: number\n): opentelemetryProto.metrics.v1.DataPoint {\n  return {\n    labels: toCollectorLabels(metric.labels),\n    value: metric.aggregator.toPoint().value as number,\n    startTimeUnixNano: startTime,\n    timeUnixNano: core.hrTimeToNanoseconds(\n      metric.aggregator.toPoint().timestamp\n    ),\n  };\n}\n\n/**\n * Returns a HistogramPoint to the collector\n * @param metric\n * @param startTime\n */\nexport function toHistogramPoint(\n  metric: MetricRecord,\n  startTime: number\n): opentelemetryProto.metrics.v1.HistogramDataPoint {\n  const { value, timestamp } = metric.aggregator.toPoint() as {\n    value: Histogram;\n    timestamp: HrTime;\n  };\n  return {\n    labels: toCollectorLabels(metric.labels),\n    sum: value.sum,\n    count: value.count,\n    startTimeUnixNano: startTime,\n    timeUnixNano: core.hrTimeToNanoseconds(timestamp),\n    bucketCounts: value.buckets.counts,\n    explicitBounds: value.buckets.boundaries,\n  };\n}\n\n/**\n * Converts a metric to be compatible with the collector\n * @param metric\n * @param startTime start time in nanoseconds\n */\nexport function toCollectorMetric(\n  metric: MetricRecord,\n  startTime: number\n): opentelemetryProto.metrics.v1.Metric {\n  const metricCollector: opentelemetryProto.metrics.v1.Metric = {\n    name: metric.descriptor.name,\n    description: metric.descriptor.description,\n    unit: metric.descriptor.unit,\n  };\n\n  if (\n    metric.aggregator.kind === AggregatorKind.SUM ||\n    metric.descriptor.metricKind === MetricKind.SUM_OBSERVER ||\n    metric.descriptor.metricKind === MetricKind.UP_DOWN_SUM_OBSERVER\n  ) {\n    const result = {\n      dataPoints: [toDataPoint(metric, startTime)],\n      isMonotonic:\n        metric.descriptor.metricKind === MetricKind.COUNTER ||\n        metric.descriptor.metricKind === MetricKind.SUM_OBSERVER,\n      aggregationTemporality: toAggregationTemporality(metric),\n    };\n    if (metric.descriptor.valueType === ValueType.INT) {\n      metricCollector.intSum = result;\n    } else {\n      metricCollector.doubleSum = result;\n    }\n  } else if (metric.aggregator.kind === AggregatorKind.LAST_VALUE) {\n    const result = {\n      dataPoints: [toDataPoint(metric, startTime)],\n    };\n    if (metric.descriptor.valueType === ValueType.INT) {\n      metricCollector.intGauge = result;\n    } else {\n      metricCollector.doubleGauge = result;\n    }\n  } else if (metric.aggregator.kind === AggregatorKind.HISTOGRAM) {\n    const result = {\n      dataPoints: [toHistogramPoint(metric, startTime)],\n      aggregationTemporality: toAggregationTemporality(metric),\n    };\n    if (metric.descriptor.valueType === ValueType.INT) {\n      metricCollector.intHistogram = result;\n    } else {\n      metricCollector.doubleHistogram = result;\n    }\n  }\n\n  return metricCollector;\n}\n\n/**\n * Prepares metric service request to be sent to collector\n * @param metrics metrics\n * @param startTime start time of the metric in nanoseconds\n * @param collectorMetricExporterBase\n */\nexport function toOTLPExportMetricServiceRequest<\n  T extends OTLPExporterConfigBase\n>(\n  metrics: MetricRecord[],\n  startTime: number,\n  collectorExporterBase: OTLPExporterBase<\n    T,\n    MetricRecord,\n    opentelemetryProto.collector.metrics.v1.ExportMetricsServiceRequest\n  >\n): opentelemetryProto.collector.metrics.v1.ExportMetricsServiceRequest {\n  const groupedMetrics: Map<\n    Resource,\n    Map<core.InstrumentationLibrary, MetricRecord[]>\n  > = groupMetricsByResourceAndLibrary(metrics);\n  const additionalAttributes = Object.assign(\n    {},\n    collectorExporterBase.attributes\n  );\n  return {\n    resourceMetrics: toCollectorResourceMetrics(\n      groupedMetrics,\n      additionalAttributes,\n      startTime\n    ),\n  };\n}\n\n/**\n * Takes an array of metrics and groups them by resource and instrumentation\n * library\n * @param metrics metrics\n */\nexport function groupMetricsByResourceAndLibrary(\n  metrics: MetricRecord[]\n): Map<Resource, Map<core.InstrumentationLibrary, MetricRecord[]>> {\n  return metrics.reduce((metricMap, metric) => {\n    //group by resource\n    let resourceMetrics = metricMap.get(metric.resource);\n    if (!resourceMetrics) {\n      resourceMetrics = new Map<core.InstrumentationLibrary, MetricRecord[]>();\n      metricMap.set(metric.resource, resourceMetrics);\n    }\n    //group by instrumentation library\n    let libMetrics = resourceMetrics.get(metric.instrumentationLibrary);\n    if (!libMetrics) {\n      libMetrics = new Array<MetricRecord>();\n      resourceMetrics.set(metric.instrumentationLibrary, libMetrics);\n    }\n    libMetrics.push(metric);\n    return metricMap;\n  }, new Map<Resource, Map<core.InstrumentationLibrary, MetricRecord[]>>());\n}\n\n/**\n * Convert to InstrumentationLibraryMetrics\n * @param instrumentationLibrary\n * @param metrics\n * @param startTime\n */\nfunction toCollectorInstrumentationLibraryMetrics(\n  instrumentationLibrary: core.InstrumentationLibrary,\n  metrics: MetricRecord[],\n  startTime: number\n): opentelemetryProto.metrics.v1.InstrumentationLibraryMetrics {\n  return {\n    metrics: metrics.map(metric => toCollectorMetric(metric, startTime)),\n    instrumentationLibrary,\n  };\n}\n\n/**\n * Returns a list of resource metrics which will be exported to the collector\n * @param groupedSpans\n * @param baseAttributes\n */\nfunction toCollectorResourceMetrics(\n  groupedMetrics: Map<\n    Resource,\n    Map<core.InstrumentationLibrary, MetricRecord[]>\n  >,\n  baseAttributes: SpanAttributes,\n  startTime: number\n): opentelemetryProto.metrics.v1.ResourceMetrics[] {\n  return Array.from(groupedMetrics, ([resource, libMetrics]) => {\n    return {\n      resource: toCollectorResource(resource, baseAttributes),\n      instrumentationLibraryMetrics: Array.from(\n        libMetrics,\n        ([instrumentationLibrary, metrics]) =>\n          toCollectorInstrumentationLibraryMetrics(\n            instrumentationLibrary,\n            metrics,\n            startTime\n          )\n      ),\n    };\n  });\n}\n"]}