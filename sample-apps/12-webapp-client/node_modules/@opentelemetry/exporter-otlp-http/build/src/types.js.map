{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanAttributes, SpanKind, SpanStatusCode } from '@opentelemetry/api';\n\n/* eslint-disable @typescript-eslint/no-namespace */\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\nexport namespace opentelemetryProto {\n  export namespace collector {\n    export namespace trace.v1 {\n      export interface TraceService {\n        service: opentelemetryProto.collector.trace.v1.TraceService;\n      }\n\n      export interface ExportTraceServiceRequest {\n        resourceSpans: opentelemetryProto.trace.v1.ResourceSpans[];\n      }\n    }\n    export namespace metrics.v1 {\n      export interface ExportMetricsServiceRequest {\n        resourceMetrics: opentelemetryProto.metrics.v1.ResourceMetrics[];\n      }\n    }\n  }\n\n  export namespace resource.v1 {\n    export interface Resource {\n      attributes: opentelemetryProto.common.v1.KeyValue[];\n      droppedAttributesCount: number;\n    }\n  }\n\n  export namespace metrics.v1 {\n    export interface Metric {\n      name: string;\n      description: string;\n      unit: string;\n      // data:\n      intGauge?: opentelemetryProto.metrics.v1.Gauge;\n      doubleGauge?: opentelemetryProto.metrics.v1.Gauge;\n      intSum?: opentelemetryProto.metrics.v1.Sum;\n      doubleSum?: opentelemetryProto.metrics.v1.Sum;\n      intHistogram?: opentelemetryProto.metrics.v1.Histogram;\n      doubleHistogram?: opentelemetryProto.metrics.v1.Histogram;\n    }\n\n    export interface Gauge {\n      dataPoints: opentelemetryProto.metrics.v1.DataPoint[];\n    }\n\n    export interface Sum {\n      dataPoints: opentelemetryProto.metrics.v1.DataPoint[];\n      aggregationTemporality: opentelemetryProto.metrics.v1.AggregationTemporality;\n      isMonotonic: boolean;\n    }\n\n    export interface Histogram {\n      dataPoints: opentelemetryProto.metrics.v1.HistogramDataPoint[];\n      aggregationTemporality: opentelemetryProto.metrics.v1.AggregationTemporality;\n    }\n\n    export interface DataPoint {\n      labels: opentelemetryProto.common.v1.StringKeyValue[];\n      startTimeUnixNano: number;\n      timeUnixNano: number;\n      value: number;\n      exemplars?: opentelemetryProto.metrics.v1.Exemplar[];\n    }\n\n    export interface Exemplar {\n      filteredLabels: opentelemetryProto.common.v1.StringKeyValue[];\n      timeUnixNano: number;\n      value: number;\n      spanId: Uint8Array;\n      traceId: Uint8Array;\n    }\n\n    export interface HistogramDataPoint {\n      labels: opentelemetryProto.common.v1.StringKeyValue[];\n      startTimeUnixNano: number;\n      timeUnixNano: number;\n      count: number;\n      sum: number;\n      bucketCounts?: number[];\n      explicitBounds?: number[];\n      exemplars?: opentelemetryProto.metrics.v1.Exemplar[][];\n    }\n\n    export interface InstrumentationLibraryMetrics {\n      instrumentationLibrary?: opentelemetryProto.common.v1.InstrumentationLibrary;\n      metrics: opentelemetryProto.metrics.v1.Metric[];\n    }\n\n    export interface ResourceMetrics {\n      resource?: opentelemetryProto.resource.v1.Resource;\n      instrumentationLibraryMetrics: opentelemetryProto.metrics.v1.InstrumentationLibraryMetrics[];\n    }\n\n    export enum AggregationTemporality {\n      // UNSPECIFIED is the default AggregationTemporality, it MUST not be used.\n      AGGREGATION_TEMPORALITY_UNSPECIFIED = 0,\n\n      // DELTA is an AggregationTemporality for a metric aggregator which reports\n      // changes since last report time. Successive metrics contain aggregation of\n      // values from continuous and non-overlapping intervals.\n      //\n      // The values for a DELTA metric are based only on the time interval\n      // associated with one measurement cycle. There is no dependency on\n      // previous measurements like is the case for CUMULATIVE metrics.\n      //\n      // For example, consider a system measuring the number of requests that\n      // it receives and reports the sum of these requests every second as a\n      // DELTA metric:\n      //\n      //   1. The system starts receiving at time=t_0.\n      //   2. A request is received, the system measures 1 request.\n      //   3. A request is received, the system measures 1 request.\n      //   4. A request is received, the system measures 1 request.\n      //   5. The 1 second collection cycle ends. A metric is exported for the\n      //      number of requests received over the interval of time t_0 to\n      //      t_0+1 with a value of 3.\n      //   6. A request is received, the system measures 1 request.\n      //   7. A request is received, the system measures 1 request.\n      //   8. The 1 second collection cycle ends. A metric is exported for the\n      //      number of requests received over the interval of time t_0+1 to\n      //      t_0+2 with a value of 2.\n      AGGREGATION_TEMPORALITY_DELTA = 1,\n\n      // CUMULATIVE is an AggregationTemporality for a metric aggregator which\n      // reports changes since a fixed start time. This means that current values\n      // of a CUMULATIVE metric depend on all previous measurements since the\n      // start time. Because of this, the sender is required to retain this state\n      // in some form. If this state is lost or invalidated, the CUMULATIVE metric\n      // values MUST be reset and a new fixed start time following the last\n      // reported measurement time sent MUST be used.\n      //\n      // For example, consider a system measuring the number of requests that\n      // it receives and reports the sum of these requests every second as a\n      // CUMULATIVE metric:\n      //\n      //   1. The system starts receiving at time=t_0.\n      //   2. A request is received, the system measures 1 request.\n      //   3. A request is received, the system measures 1 request.\n      //   4. A request is received, the system measures 1 request.\n      //   5. The 1 second collection cycle ends. A metric is exported for the\n      //      number of requests received over the interval of time t_0 to\n      //      t_0+1 with a value of 3.\n      //   6. A request is received, the system measures 1 request.\n      //   7. A request is received, the system measures 1 request.\n      //   8. The 1 second collection cycle ends. A metric is exported for the\n      //      number of requests received over the interval of time t_0 to\n      //      t_0+2 with a value of 5.\n      //   9. The system experiences a fault and loses state.\n      //   10. The system recovers and resumes receiving at time=t_1.\n      //   11. A request is received, the system measures 1 request.\n      //   12. The 1 second collection cycle ends. A metric is exported for the\n      //      number of requests received over the interval of time t_1 to\n      //      t_0+1 with a value of 1.\n      //\n      // Note: Even though, when reporting changes since last report time, using\n      // CUMULATIVE is valid, it is not recommended. This may cause problems for\n      // systems that do not use start_time to determine when the aggregation\n      // value was reset (e.g. Prometheus).\n      AGGREGATION_TEMPORALITY_CUMULATIVE = 2,\n    }\n  }\n\n  export namespace trace.v1 {\n    export namespace ConstantSampler {\n      export enum ConstantDecision {\n        ALWAYS_OFF = 0,\n        ALWAYS_ON = 1,\n        ALWAYS_PARENT = 2,\n      }\n    }\n    export namespace Span {\n      export interface Event {\n        timeUnixNano: number;\n        name: string;\n        attributes?: opentelemetryProto.common.v1.KeyValue[];\n        droppedAttributesCount: number;\n      }\n\n      export interface Link {\n        traceId: string;\n        spanId: string;\n        traceState?: opentelemetryProto.trace.v1.Span.TraceState;\n        attributes?: opentelemetryProto.common.v1.KeyValue[];\n        droppedAttributesCount: number;\n      }\n\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n      export enum SpanKind {\n        SPAN_KIND_UNSPECIFIED,\n        SPAN_KIND_INTERNAL,\n        SPAN_KIND_SERVER,\n        SPAN_KIND_CLIENT,\n        SPAN_KIND_PRODUCER,\n        SPAN_KIND_CONSUMER,\n      }\n\n      export type TraceState = string | undefined;\n    }\n\n    export interface ConstantSampler {\n      decision?: opentelemetryProto.trace.v1.ConstantSampler.ConstantDecision;\n    }\n\n    export interface InstrumentationLibrarySpans {\n      instrumentationLibrary?: opentelemetryProto.common.v1.InstrumentationLibrary;\n      spans: opentelemetryProto.trace.v1.Span[];\n    }\n\n    export interface ProbabilitySampler {\n      samplingProbability?: number | null;\n    }\n\n    export interface RateLimitingSampler {\n      qps?: number | null;\n    }\n\n    export interface ResourceSpans {\n      resource?: opentelemetryProto.resource.v1.Resource;\n      instrumentationLibrarySpans: opentelemetryProto.trace.v1.InstrumentationLibrarySpans[];\n    }\n\n    export interface Span {\n      traceId: string;\n      spanId: string;\n      traceState: opentelemetryProto.trace.v1.Span.TraceState;\n      parentSpanId?: string;\n      name?: string;\n      kind?: opentelemetryProto.trace.v1.Span.SpanKind;\n      startTimeUnixNano?: number;\n      endTimeUnixNano?: number;\n      attributes?: opentelemetryProto.common.v1.KeyValue[];\n      droppedAttributesCount: number;\n      events?: opentelemetryProto.trace.v1.Span.Event[];\n      droppedEventsCount: number;\n      links?: opentelemetryProto.trace.v1.Span.Link[];\n      droppedLinksCount: number;\n      status?: SpanStatus;\n    }\n\n    export interface SpanStatus {\n      /** The status code of this message. */\n      code: SpanStatusCode;\n      /** A developer-facing error message. */\n      message?: string;\n    }\n\n    export interface TraceConfig {\n      constantSampler?: ConstantSampler | null;\n      probabilitySampler?: ProbabilitySampler | null;\n      rateLimitingSampler?: RateLimitingSampler | null;\n    }\n  }\n  export namespace common.v1 {\n    export interface KeyValue {\n      key: string;\n      value: AnyValue;\n    }\n\n    export type ArrayValue = {\n      values: AnyValue[];\n    };\n\n    export interface KeyValueList {\n      values: KeyValue[];\n    }\n\n    export type AnyValue = {\n      stringValue?: string;\n      boolValue?: boolean;\n      intValue?: number;\n      doubleValue?: number;\n      arrayValue?: ArrayValue;\n      kvlistValue?: KeyValueList;\n    };\n\n    export interface InstrumentationLibrary {\n      name: string;\n      version?: string;\n    }\n\n    export interface StringKeyValue {\n      key: string;\n      value: string;\n    }\n\n    export enum ValueType {\n      STRING,\n      INT,\n      DOUBLE,\n      BOOL,\n    }\n  }\n}\n\n/**\n * Interface for handling error\n */\nexport class OTLPExporterError extends Error {\n  readonly code?: number;\n  override readonly name: string = 'OTLPExporterError';\n  readonly data?: string;\n\n  constructor(message?: string, code?: number, data?: string) {\n    super(message);\n    this.data = data;\n    this.code = code;\n  }\n}\n\n/**\n * Interface for handling export service errors\n */\nexport interface ExportServiceError {\n  name: string;\n  code: number;\n  details: string;\n  metadata: { [key: string]: unknown };\n  message: string;\n  stack: string;\n}\n\n/**\n * Collector Exporter base config\n */\nexport interface OTLPExporterConfigBase {\n  headers?: Partial<Record<string, unknown>>;\n  hostname?: string;\n  attributes?: SpanAttributes;\n  url?: string;\n  concurrencyLimit?: number;\n}\n\n/**\n * Mapping between api SpanKind and proto SpanKind\n */\nexport const OTLP_SPAN_KIND_MAPPING = {\n  [SpanKind.INTERNAL]:\n    opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_INTERNAL,\n  [SpanKind.SERVER]: opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_SERVER,\n  [SpanKind.CLIENT]: opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_CLIENT,\n  [SpanKind.PRODUCER]:\n    opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_PRODUCER,\n  [SpanKind.CONSUMER]:\n    opentelemetryProto.trace.v1.Span.SpanKind.SPAN_KIND_CONSUMER,\n};\n"]}