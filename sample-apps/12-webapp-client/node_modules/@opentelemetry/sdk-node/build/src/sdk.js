"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeSDK = void 0;
const api_metrics_1 = require("@opentelemetry/api-metrics");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const resources_1 = require("@opentelemetry/resources");
const sdk_metrics_base_1 = require("@opentelemetry/sdk-metrics-base");
const sdk_trace_base_1 = require("@opentelemetry/sdk-trace-base");
const sdk_trace_node_1 = require("@opentelemetry/sdk-trace-node");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
/** This class represents everything needed to register a fully configured OpenTelemetry Node.js SDK */
class NodeSDK {
    /**
     * Create a new NodeJS SDK instance
     */
    constructor(configuration = {}) {
        var _a, _b, _c;
        this._resource = (_a = configuration.resource) !== null && _a !== void 0 ? _a : new resources_1.Resource({});
        this._serviceName = configuration.serviceName;
        this._autoDetectResources = (_b = configuration.autoDetectResources) !== null && _b !== void 0 ? _b : true;
        if (configuration.spanProcessor || configuration.traceExporter) {
            const tracerProviderConfig = {};
            if (configuration.sampler) {
                tracerProviderConfig.sampler = configuration.sampler;
            }
            if (configuration.spanLimits) {
                tracerProviderConfig.spanLimits = configuration.spanLimits;
            }
            const spanProcessor = (_c = configuration.spanProcessor) !== null && _c !== void 0 ? _c : new sdk_trace_base_1.BatchSpanProcessor(configuration.traceExporter);
            this.configureTracerProvider(tracerProviderConfig, spanProcessor, configuration.contextManager, configuration.textMapPropagator);
        }
        if (configuration.metricReader) {
            this.configureMeterProvider(configuration.metricReader);
        }
        let instrumentations = [];
        if (configuration.instrumentations) {
            instrumentations = configuration.instrumentations;
        }
        this._instrumentations = instrumentations;
    }
    /** Set configurations required to register a NodeTracerProvider */
    configureTracerProvider(tracerConfig, spanProcessor, contextManager, textMapPropagator) {
        this._tracerProviderConfig = {
            tracerConfig,
            spanProcessor,
            contextManager,
            textMapPropagator,
        };
    }
    /** Set configurations needed to register a MeterProvider */
    configureMeterProvider(reader) {
        this._metricReader = reader;
    }
    /** Detect resource attributes */
    async detectResources(config) {
        const internalConfig = Object.assign({ detectors: [resources_1.envDetector, resources_1.processDetector] }, config);
        this.addResource(await (0, resources_1.detectResources)(internalConfig));
    }
    /** Manually add a resource */
    addResource(resource) {
        this._resource = this._resource.merge(resource);
    }
    /**
     * Once the SDK has been configured, call this method to construct SDK components and register them with the OpenTelemetry API.
     */
    async start() {
        if (this._autoDetectResources) {
            await this.detectResources();
        }
        this._resource = this._serviceName === undefined
            ? this._resource
            : this._resource.merge(new resources_1.Resource({ [semantic_conventions_1.SemanticResourceAttributes.SERVICE_NAME]: this._serviceName }));
        if (this._tracerProviderConfig) {
            const tracerProvider = new sdk_trace_node_1.NodeTracerProvider(Object.assign(Object.assign({}, this._tracerProviderConfig.tracerConfig), { resource: this._resource }));
            this._tracerProvider = tracerProvider;
            tracerProvider.addSpanProcessor(this._tracerProviderConfig.spanProcessor);
            tracerProvider.register({
                contextManager: this._tracerProviderConfig.contextManager,
                propagator: this._tracerProviderConfig.textMapPropagator,
            });
        }
        if (this._metricReader) {
            const meterProvider = new sdk_metrics_base_1.MeterProvider({
                resource: this._resource,
            });
            meterProvider.addMetricReader(this._metricReader);
            this._meterProvider = meterProvider;
            api_metrics_1.metrics.setGlobalMeterProvider(meterProvider);
        }
        (0, instrumentation_1.registerInstrumentations)({
            instrumentations: this._instrumentations,
        });
    }
    shutdown() {
        const promises = [];
        if (this._tracerProvider) {
            promises.push(this._tracerProvider.shutdown());
        }
        if (this._meterProvider) {
            promises.push(this._meterProvider.shutdown());
        }
        return (Promise.all(promises)
            // return void instead of the array from Promise.all
            .then(() => {
        }));
    }
}
exports.NodeSDK = NodeSDK;
//# sourceMappingURL=sdk.js.map