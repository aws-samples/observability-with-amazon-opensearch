{"version":3,"file":"ObservableRegistry.js","sourceRoot":"","sources":["../../../src/state/ObservableRegistry.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport { HrTime } from '@opentelemetry/api';\nimport { BatchObservableCallback, Observable, ObservableCallback } from '@opentelemetry/api-metrics';\nimport { isObservableInstrument, ObservableInstrument } from '../Instruments';\nimport { BatchObservableResultImpl, ObservableResultImpl } from '../ObservableResult';\nimport { callWithTimeout, PromiseAllSettled, isPromiseAllSettledRejectionResult, setEquals } from '../utils';\n\n/**\n * Records for single instrument observable callback.\n */\ninterface ObservableCallbackRecord {\n  callback: ObservableCallback;\n  instrument: ObservableInstrument;\n}\n\n/**\n * Records for multiple instruments observable callback.\n */\ninterface BatchObservableCallbackRecord {\n  callback: BatchObservableCallback;\n  instruments: Set<ObservableInstrument>;\n}\n\n/**\n * An internal interface for managing ObservableCallbacks.\n *\n * Every registered callback associated with a set of instruments are be evaluated\n * exactly once during collection prior to reading data for that instrument.\n */\nexport class ObservableRegistry {\n  private _callbacks: ObservableCallbackRecord[] = [];\n  private _batchCallbacks: BatchObservableCallbackRecord[] = [];\n\n  addCallback(callback: ObservableCallback, instrument: ObservableInstrument) {\n    const idx = this._findCallback(callback, instrument);\n    if (idx >= 0) {\n      return;\n    }\n    this._callbacks.push({ callback, instrument });\n  }\n\n  removeCallback(callback: ObservableCallback, instrument: ObservableInstrument) {\n    const idx = this._findCallback(callback, instrument);\n    if (idx < 0) {\n      return;\n    }\n    this._callbacks.splice(idx, 1);\n  }\n\n  addBatchCallback(callback: BatchObservableCallback, instruments: Observable[]) {\n    // Create a set of unique instruments.\n    const observableInstruments = new Set(instruments.filter(isObservableInstrument));\n    if (observableInstruments.size === 0) {\n      api.diag.error('BatchObservableCallback is not associated with valid instruments', instruments);\n      return;\n    }\n    const idx = this._findBatchCallback(callback, observableInstruments);\n    if (idx >= 0) {\n      return;\n    }\n    this._batchCallbacks.push({ callback, instruments: observableInstruments });\n  }\n\n  removeBatchCallback(callback: BatchObservableCallback, instruments: Observable[]) {\n    // Create a set of unique instruments.\n    const observableInstruments = new Set(instruments.filter(isObservableInstrument));\n    const idx = this._findBatchCallback(callback, observableInstruments);\n    if (idx < 0) {\n      return;\n    }\n    this._batchCallbacks.splice(idx, 1);\n  }\n\n  /**\n   * @returns a promise of rejected reasons for invoking callbacks.\n   */\n  async observe(collectionTime: HrTime, timeoutMillis?: number): Promise<unknown[]> {\n    const callbackFutures = this._observeCallbacks(collectionTime, timeoutMillis);\n    const batchCallbackFutures = this._observeBatchCallbacks(collectionTime, timeoutMillis);\n\n    const results = await PromiseAllSettled([...callbackFutures, ...batchCallbackFutures]);\n\n    const rejections = results.filter(isPromiseAllSettledRejectionResult)\n      .map(it => it.reason);\n    return rejections;\n  }\n\n  private _observeCallbacks(observationTime: HrTime, timeoutMillis?: number) {\n    return this._callbacks\n      .map(async ({ callback, instrument }) => {\n        const observableResult = new ObservableResultImpl(instrument._descriptor);\n        let callPromise: Promise<void> = Promise.resolve(callback(observableResult));\n        if (timeoutMillis != null) {\n          callPromise = callWithTimeout(callPromise, timeoutMillis);\n        }\n        await callPromise;\n        instrument._metricStorages.forEach(metricStorage => {\n          metricStorage.record(observableResult._buffer, observationTime);\n        });\n      });\n  }\n\n  private _observeBatchCallbacks(observationTime: HrTime, timeoutMillis?: number) {\n    return this._batchCallbacks\n      .map(async ({ callback, instruments }) => {\n        const observableResult = new BatchObservableResultImpl();\n        let callPromise: Promise<void> = Promise.resolve(callback(observableResult));\n        if (timeoutMillis != null) {\n          callPromise = callWithTimeout(callPromise, timeoutMillis);\n        }\n        await callPromise;\n        instruments.forEach(instrument => {\n          const buffer = observableResult._buffer.get(instrument);\n          if (buffer == null) {\n            return;\n          }\n          instrument._metricStorages.forEach(metricStorage => {\n            metricStorage.record(buffer, observationTime);\n          });\n        });\n      });\n  }\n\n  private _findCallback(callback: ObservableCallback, instrument: ObservableInstrument) {\n    return this._callbacks.findIndex(record => {\n      return record.callback === callback && record.instrument === instrument;\n    });\n  }\n\n  private _findBatchCallback(callback: BatchObservableCallback, instruments: Set<ObservableInstrument>) {\n    return this._batchCallbacks.findIndex(record => {\n      return record.callback === callback && setEquals(record.instruments, instruments);\n    });\n  }\n}\n"]}