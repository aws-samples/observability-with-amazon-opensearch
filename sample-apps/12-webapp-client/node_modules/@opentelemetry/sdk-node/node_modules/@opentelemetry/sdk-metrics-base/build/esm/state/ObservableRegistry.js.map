{"version":3,"file":"ObservableRegistry.js","sourceRoot":"","sources":["../../../src/state/ObservableRegistry.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport { HrTime } from '@opentelemetry/api';\nimport { BatchObservableCallback, Observable, ObservableCallback } from '@opentelemetry/api-metrics';\nimport { isObservableInstrument, ObservableInstrument } from '../Instruments';\nimport { BatchObservableResultImpl, ObservableResultImpl } from '../ObservableResult';\nimport { callWithTimeout, PromiseAllSettled, isPromiseAllSettledRejectionResult, setEquals } from '../utils';\n\n/**\n * Records for single instrument observable callback.\n */\ninterface ObservableCallbackRecord {\n  callback: ObservableCallback;\n  instrument: ObservableInstrument;\n}\n\n/**\n * Records for multiple instruments observable callback.\n */\ninterface BatchObservableCallbackRecord {\n  callback: BatchObservableCallback;\n  instruments: Set<ObservableInstrument>;\n}\n\n/**\n * An internal interface for managing ObservableCallbacks.\n *\n * Every registered callback associated with a set of instruments are be evaluated\n * exactly once during collection prior to reading data for that instrument.\n */\nexport class ObservableRegistry {\n  private _callbacks: ObservableCallbackRecord[] = [];\n  private _batchCallbacks: BatchObservableCallbackRecord[] = [];\n\n  addCallback(callback: ObservableCallback, instrument: ObservableInstrument) {\n    const idx = this._findCallback(callback, instrument);\n    if (idx >= 0) {\n      return;\n    }\n    this._callbacks.push({ callback, instrument });\n  }\n\n  removeCallback(callback: ObservableCallback, instrument: ObservableInstrument) {\n    const idx = this._findCallback(callback, instrument);\n    if (idx < 0) {\n      return;\n    }\n    this._callbacks.splice(idx, 1);\n  }\n\n  addBatchCallback(callback: BatchObservableCallback, instruments: Observable[]) {\n    // Create a set of unique instruments.\n    const observableInstruments = new Set(instruments.filter(isObservableInstrument));\n    if (observableInstruments.size === 0) {\n      api.diag.error('BatchObservableCallback is not associated with valid instruments', instruments);\n      return;\n    }\n    const idx = this._findBatchCallback(callback, observableInstruments);\n    if (idx >= 0) {\n      return;\n    }\n    this._batchCallbacks.push({ callback, instruments: observableInstruments });\n  }\n\n  removeBatchCallback(callback: BatchObservableCallback, instruments: Observable[]) {\n    // Create a set of unique instruments.\n    const observableInstruments = new Set(instruments.filter(isObservableInstrument));\n    const idx = this._findBatchCallback(callback, observableInstruments);\n    if (idx < 0) {\n      return;\n    }\n    this._batchCallbacks.splice(idx, 1);\n  }\n\n  /**\n   * @returns a promise of rejected reasons for invoking callbacks.\n   */\n  async observe(collectionTime: HrTime, timeoutMillis?: number): Promise<unknown[]> {\n    const callbackFutures = this._observeCallbacks(collectionTime, timeoutMillis);\n    const batchCallbackFutures = this._observeBatchCallbacks(collectionTime, timeoutMillis);\n\n    const results = await PromiseAllSettled([...callbackFutures, ...batchCallbackFutures]);\n\n    const rejections = results.filter(isPromiseAllSettledRejectionResult)\n      .map(it => it.reason);\n    return rejections;\n  }\n\n  private _observeCallbacks(observationTime: HrTime, timeoutMillis?: number) {\n    return this._callbacks\n      .map(async ({ callback, instrument }) => {\n        const observableResult = new ObservableResultImpl(instrument._descriptor);\n        let callPromise: Promise<void> = Promise.resolve(callback(observableResult));\n        if (timeoutMillis != null) {\n          callPromise = callWithTimeout(callPromise, timeoutMillis);\n        }\n        await callPromise;\n        instrument._metricStorages.forEach(metricStorage => {\n          metricStorage.record(observableResult._buffer, observationTime);\n        });\n      });\n  }\n\n  private _observeBatchCallbacks(observationTime: HrTime, timeoutMillis?: number) {\n    return this._batchCallbacks\n      .map(async ({ callback, instruments }) => {\n        const observableResult = new BatchObservableResultImpl();\n        let callPromise: Promise<void> = Promise.resolve(callback(observableResult));\n        if (timeoutMillis != null) {\n          callPromise = callWithTimeout(callPromise, timeoutMillis);\n        }\n        await callPromise;\n        instruments.forEach(instrument => {\n          const buffer = observableResult._buffer.get(instrument);\n          if (buffer == null) {\n            return;\n          }\n          instrument._metricStorages.forEach(metricStorage => {\n            metricStorage.record(buffer, observationTime);\n          });\n        });\n      });\n  }\n\n  private _findCallback(callback: ObservableCallback, instrument: ObservableInstrument) {\n    return this._callbacks.findIndex(record => {\n      return record.callback === callback && record.instrument === instrument;\n    });\n  }\n\n  private _findBatchCallback(callback: BatchObservableCallback, instruments: Set<ObservableInstrument>) {\n    return this._batchCallbacks.findIndex(record => {\n      return record.callback === callback && setEquals(record.instruments, instruments);\n    });\n  }\n}\n"]}