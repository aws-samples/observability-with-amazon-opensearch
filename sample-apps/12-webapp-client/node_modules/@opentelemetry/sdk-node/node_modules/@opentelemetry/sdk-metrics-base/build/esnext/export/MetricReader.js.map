{"version":3,"file":"MetricReader.js","sourceRoot":"","sources":["../../../src/export/MetricReader.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG;AAEH,OAAO,KAAK,GAAG,MAAM,oBAAoB,CAAC;AAI1C,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAI3C;;;GAGG;AACH,MAAM,OAAgB,YAAY;IAAlC;QACE,6BAA6B;QAC7B,yFAAyF;QACjF,cAAS,GAAG,KAAK,CAAC;IA6G5B,CAAC;IAzGC;;;;OAIG;IACH,iBAAiB,CAAC,cAA8B;QAC9C,IAAI,IAAI,CAAC,eAAe,EAAE;YACxB,MAAM,IAAI,KAAK,CAAC,yDAAyD,CAAC,CAAC;SAC5E;QACD,IAAI,CAAC,eAAe,GAAG,cAAc,CAAC;QACtC,IAAI,CAAC,aAAa,EAAE,CAAC;IACvB,CAAC;IAQD;;;OAGG;IACO,aAAa;QACrB,mCAAmC;IACrC,CAAC;IAmBD;;OAEG;IACH,KAAK,CAAC,OAAO,CAAC,OAA2B;QACvC,IAAI,IAAI,CAAC,eAAe,KAAK,SAAS,EAAE;YACtC,MAAM,IAAI,KAAK,CAAC,+CAA+C,CAAC,CAAC;SAClE;QAED,sGAAsG;QACtG,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC;SAC7C;QAED,OAAO,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC;YAClC,aAAa,EAAE,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,aAAa;SACtC,CAAC,CAAC;IACL,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,QAAQ,CAAC,OAAyB;QACtC,4DAA4D;QAC5D,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,6BAA6B,CAAC,CAAC;YAC9C,OAAO;SACR;QAED,oDAAoD;QACpD,IAAI,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,aAAa,KAAI,IAAI,EAAE;YAClC,MAAM,IAAI,CAAC,UAAU,EAAE,CAAC;SACzB;aAAM;YACL,MAAM,eAAe,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE,OAAO,CAAC,aAAa,CAAC,CAAC;SACjE;QAED,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;IACxB,CAAC;IAED;;;;;OAKG;IACH,KAAK,CAAC,UAAU,CAAC,OAA2B;QAC1C,IAAI,IAAI,CAAC,SAAS,EAAE;YAClB,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,qDAAqD,CAAC,CAAC;YACrE,OAAO;SACR;QAED,oDAAoD;QACpD,IAAI,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,aAAa,KAAI,IAAI,EAAE;YAClC,MAAM,IAAI,CAAC,YAAY,EAAE,CAAC;YAC1B,OAAO;SACR;QAED,MAAM,eAAe,CAAC,IAAI,CAAC,YAAY,EAAE,EAAE,OAAO,CAAC,aAAa,CAAC,CAAC;IACpE,CAAC;CACF","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport { AggregationTemporality } from './AggregationTemporality';\nimport { MetricProducer } from './MetricProducer';\nimport { CollectionResult } from './MetricData';\nimport { callWithTimeout } from '../utils';\nimport { InstrumentType } from '../InstrumentDescriptor';\nimport { CollectionOptions, ForceFlushOptions, ShutdownOptions } from '../types';\n\n/**\n * A registered reader of metrics that, when linked to a {@link MetricProducer}, offers global\n * control over metrics.\n */\nexport abstract class MetricReader {\n  // Tracks the shutdown state.\n  // TODO: use BindOncePromise here once a new version of @opentelemetry/core is available.\n  private _shutdown = false;\n  // MetricProducer used by this instance.\n  private _metricProducer?: MetricProducer;\n\n  /**\n   * Set the {@link MetricProducer} used by this instance.\n   *\n   * @param metricProducer\n   */\n  setMetricProducer(metricProducer: MetricProducer) {\n    if (this._metricProducer) {\n      throw new Error('MetricReader can not be bound to a MeterProvider again.');\n    }\n    this._metricProducer = metricProducer;\n    this.onInitialized();\n  }\n\n  /**\n   * Select the {@link AggregationTemporality} for the given\n   * {@link InstrumentType} for this reader.\n   */\n  abstract selectAggregationTemporality(instrumentType: InstrumentType): AggregationTemporality;\n\n  /**\n   * Handle once the SDK has initialized this {@link MetricReader}\n   * Overriding this method is optional.\n   */\n  protected onInitialized(): void {\n    // Default implementation is empty.\n  }\n\n  /**\n   * Handle a shutdown signal by the SDK.\n   *\n   * <p> For push exporters, this should shut down any intervals and close any open connections.\n   * @protected\n   */\n  protected abstract onShutdown(): Promise<void>;\n\n  /**\n   * Handle a force flush signal by the SDK.\n   *\n   * <p> In all scenarios metrics should be collected via {@link collect()}.\n   * <p> For push exporters, this should collect and report metrics.\n   * @protected\n   */\n  protected abstract onForceFlush(): Promise<void>;\n\n  /**\n   * Collect all metrics from the associated {@link MetricProducer}\n   */\n  async collect(options?: CollectionOptions): Promise<CollectionResult> {\n    if (this._metricProducer === undefined) {\n      throw new Error('MetricReader is not bound to a MetricProducer');\n    }\n\n    // Subsequent invocations to collect are not allowed. SDKs SHOULD return some failure for these calls.\n    if (this._shutdown) {\n      throw new Error('MetricReader is shutdown');\n    }\n\n    return this._metricProducer.collect({\n      timeoutMillis: options?.timeoutMillis,\n    });\n  }\n\n  /**\n   * Shuts down the metric reader, the promise will reject after the optional timeout or resolve after completion.\n   *\n   * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.\n   * @param options options with timeout.\n   */\n  async shutdown(options?: ShutdownOptions): Promise<void> {\n    // Do not call shutdown again if it has already been called.\n    if (this._shutdown) {\n      api.diag.error('Cannot call shutdown twice.');\n      return;\n    }\n\n    // No timeout if timeoutMillis is undefined or null.\n    if (options?.timeoutMillis == null) {\n      await this.onShutdown();\n    } else {\n      await callWithTimeout(this.onShutdown(), options.timeoutMillis);\n    }\n\n    this._shutdown = true;\n  }\n\n  /**\n   * Flushes metrics read by this reader, the promise will reject after the optional timeout or resolve after completion.\n   *\n   * <p> NOTE: this operation will continue even after the promise rejects due to a timeout.\n   * @param options options with timeout.\n   */\n  async forceFlush(options?: ForceFlushOptions): Promise<void> {\n    if (this._shutdown) {\n      api.diag.warn('Cannot forceFlush on already shutdown MetricReader.');\n      return;\n    }\n\n    // No timeout if timeoutMillis is undefined or null.\n    if (options?.timeoutMillis == null) {\n      await this.onForceFlush();\n      return;\n    }\n\n    await callWithTimeout(this.onForceFlush(), options.timeoutMillis);\n  }\n}\n"]}