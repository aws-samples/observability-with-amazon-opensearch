{"version":3,"file":"Aggregation.js","sourceRoot":"","sources":["../../../src/view/Aggregation.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport { Aggregator, SumAggregator, DropAggregator, LastValueAggregator, HistogramAggregator } from '../aggregator';\nimport { Accumulation } from '../aggregator/types';\nimport { InstrumentDescriptor, InstrumentType } from '../InstrumentDescriptor';\nimport { Maybe } from '../utils';\n\n/**\n * Configures how measurements are combined into metrics for views.\n *\n * Aggregation provides a set of built-in aggregations via static methods.\n */\nexport abstract class Aggregation {\n  abstract createAggregator(instrument: InstrumentDescriptor): Aggregator<Maybe<Accumulation>>;\n\n  static Drop(): Aggregation {\n    return DROP_AGGREGATION;\n  }\n\n  static Sum(): Aggregation {\n    return SUM_AGGREGATION;\n  }\n\n  static LastValue(): Aggregation {\n    return LAST_VALUE_AGGREGATION;\n  }\n\n  static Histogram(): Aggregation {\n    return HISTOGRAM_AGGREGATION;\n  }\n\n  static Default(): Aggregation {\n    return DEFAULT_AGGREGATION;\n  }\n}\n\n/**\n * The default drop aggregation.\n */\nexport class DropAggregation extends Aggregation {\n  private static DEFAULT_INSTANCE = new DropAggregator();\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return DropAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The default sum aggregation.\n */\nexport class SumAggregation extends Aggregation {\n  private static MONOTONIC_INSTANCE = new SumAggregator(true);\n  private static NON_MONOTONIC_INSTANCE = new SumAggregator(false);\n  createAggregator(instrument: InstrumentDescriptor) {\n    switch (instrument.type) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.HISTOGRAM: {\n        return SumAggregation.MONOTONIC_INSTANCE;\n      }\n      default: {\n        return SumAggregation.NON_MONOTONIC_INSTANCE;\n      }\n    }\n  }\n}\n\n/**\n * The default last value aggregation.\n */\nexport class LastValueAggregation extends Aggregation {\n  private static DEFAULT_INSTANCE = new LastValueAggregator();\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return LastValueAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The default histogram aggregation.\n */\nexport class HistogramAggregation extends Aggregation {\n  private static DEFAULT_INSTANCE = new HistogramAggregator([0, 5, 10, 25, 50, 75, 100, 250, 500, 1000], true);\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return HistogramAggregation.DEFAULT_INSTANCE;\n  }\n}\n\n/**\n * The explicit bucket histogram aggregation.\n */\nexport class ExplicitBucketHistogramAggregation extends Aggregation {\n  private _boundaries: number[];\n\n  /**\n   * @param boundaries the bucket boundaries of the histogram aggregation\n   * @param _recordMinMax If set to true, min and max will be recorded. Otherwise, min and max will not be recorded.\n   */\n  constructor(boundaries: number[], private readonly _recordMinMax = true) {\n    super();\n    if (boundaries === undefined || boundaries.length === 0) {\n      throw new Error('HistogramAggregator should be created with boundaries.');\n    }\n    // Copy the boundaries array for modification.\n    boundaries = boundaries.concat();\n    // We need to an ordered set to be able to correctly compute count for each\n    // boundary since we'll iterate on each in order.\n    boundaries = boundaries.sort((a, b) => a - b);\n    // Remove all Infinity from the boundaries.\n    const minusInfinityIndex = boundaries.lastIndexOf(-Infinity);\n    let infinityIndex: number | undefined = boundaries.indexOf(Infinity);\n    if (infinityIndex === -1) {\n      infinityIndex = undefined;\n    }\n    this._boundaries = boundaries.slice(minusInfinityIndex + 1, infinityIndex);\n  }\n\n  createAggregator(_instrument: InstrumentDescriptor) {\n    return new HistogramAggregator(this._boundaries, this._recordMinMax);\n  }\n}\n\n/**\n * The default aggregation.\n */\nexport class DefaultAggregation extends Aggregation {\n  private _resolve(instrument: InstrumentDescriptor): Aggregation {\n    // cast to unknown to disable complaints on the (unreachable) fallback.\n    switch (instrument.type as unknown) {\n      case InstrumentType.COUNTER:\n      case InstrumentType.UP_DOWN_COUNTER:\n      case InstrumentType.OBSERVABLE_COUNTER:\n      case InstrumentType.OBSERVABLE_UP_DOWN_COUNTER: {\n        return SUM_AGGREGATION;\n      }\n      case InstrumentType.OBSERVABLE_GAUGE: {\n        return LAST_VALUE_AGGREGATION;\n      }\n      case InstrumentType.HISTOGRAM: {\n        return HISTOGRAM_AGGREGATION;\n      }\n    }\n    api.diag.warn(`Unable to recognize instrument type: ${instrument.type}`);\n    return DROP_AGGREGATION;\n  }\n\n  createAggregator(instrument: InstrumentDescriptor): Aggregator<Maybe<Accumulation>> {\n    return this._resolve(instrument).createAggregator(instrument);\n  }\n}\n\nconst DROP_AGGREGATION = new DropAggregation();\nconst SUM_AGGREGATION = new SumAggregation();\nconst LAST_VALUE_AGGREGATION = new LastValueAggregation();\nconst HISTOGRAM_AGGREGATION = new HistogramAggregation();\nconst DEFAULT_AGGREGATION = new DefaultAggregation();\n"]}