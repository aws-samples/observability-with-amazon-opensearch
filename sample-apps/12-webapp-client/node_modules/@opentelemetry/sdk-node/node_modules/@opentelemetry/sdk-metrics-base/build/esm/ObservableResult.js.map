{"version":3,"file":"ObservableResult.js","sourceRoot":"","sources":["../../src/ObservableResult.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG;AAEH,OAAO,KAAK,GAAG,MAAM,oBAAoB,CAAC;AAC1C,OAAO,KAAK,OAAO,MAAM,4BAA4B,CAAC;AACtD,OAAO,EAAE,gBAAgB,EAAE,MAAM,iBAAiB,CAAC;AACnD,OAAO,EAAE,sBAAsB,EAAwB,MAAM,eAAe,CAAC;AAG7E;;GAEG;AACH;IAME,8BAAoB,WAAiC;QAAjC,gBAAW,GAAX,WAAW,CAAsB;QALrD;;WAEG;QACH,YAAO,GAAG,IAAI,gBAAgB,EAAU,CAAC;IAEe,CAAC;IAEzD;;OAEG;IACH,sCAAO,GAAP,UAAQ,KAAa,EAAE,UAAyC;QAAzC,2BAAA,EAAA,eAAyC;QAC9D,IAAI,IAAI,CAAC,WAAW,CAAC,SAAS,KAAK,OAAO,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;YACpF,GAAG,CAAC,IAAI,CAAC,IAAI,CACX,6DAA2D,IAAI,CAAC,WAAW,CAAC,IAAI,sCAAmC,CACpH,CAAC;YACF,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;SAC3B;QACD,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;IACtC,CAAC;IACH,2BAAC;AAAD,CAAC,AApBD,IAoBC;;AAED;;GAEG;AACH;IAAA;QACE;;WAEG;QACH,YAAO,GAAwD,IAAI,GAAG,EAAE,CAAC;IAsB3E,CAAC;IApBC;;OAEG;IACH,2CAAO,GAAP,UAAQ,MAA0B,EAAE,KAAa,EAAE,UAAyC;QAAzC,2BAAA,EAAA,eAAyC;QAC1F,IAAI,CAAC,sBAAsB,CAAC,MAAM,CAAC,EAAE;YACnC,OAAO;SACR;QACD,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;QACnC,IAAI,GAAG,IAAI,IAAI,EAAE;YACf,GAAG,GAAG,IAAI,gBAAgB,EAAE,CAAC;YAC7B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC;SAC/B;QACD,IAAI,MAAM,CAAC,WAAW,CAAC,SAAS,KAAK,OAAO,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE;YACtF,GAAG,CAAC,IAAI,CAAC,IAAI,CACX,6DAA2D,MAAM,CAAC,WAAW,CAAC,IAAI,sCAAmC,CACtH,CAAC;YACF,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;SAC3B;QACD,GAAG,CAAC,GAAG,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC;IAC7B,CAAC;IACH,gCAAC;AAAD,CAAC,AA1BD,IA0BC","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport * as metrics from '@opentelemetry/api-metrics';\nimport { AttributeHashMap } from './state/HashMap';\nimport { isObservableInstrument, ObservableInstrument } from './Instruments';\nimport { InstrumentDescriptor } from '.';\n\n/**\n * The class implements {@link metrics.ObservableResult} interface.\n */\nexport class ObservableResultImpl implements metrics.ObservableResult {\n  /**\n   * @internal\n   */\n  _buffer = new AttributeHashMap<number>();\n\n  constructor(private _descriptor: InstrumentDescriptor) {}\n\n  /**\n   * Observe a measurement of the value associated with the given attributes.\n   */\n  observe(value: number, attributes: metrics.MetricAttributes = {}): void {\n    if (this._descriptor.valueType === metrics.ValueType.INT && !Number.isInteger(value)) {\n      api.diag.warn(\n        `INT value type cannot accept a floating-point value for ${this._descriptor.name}, ignoring the fractional digits.`\n      );\n      value = Math.trunc(value);\n    }\n    this._buffer.set(attributes, value);\n  }\n}\n\n/**\n * The class implements {@link metrics.BatchObservableCallback} interface.\n */\nexport class BatchObservableResultImpl implements metrics.BatchObservableResult {\n  /**\n   * @internal\n   */\n  _buffer: Map<ObservableInstrument, AttributeHashMap<number>> = new Map();\n\n  /**\n   * Observe a measurement of the value associated with the given attributes.\n   */\n  observe(metric: metrics.Observable, value: number, attributes: metrics.MetricAttributes = {}): void {\n    if (!isObservableInstrument(metric)) {\n      return;\n    }\n    let map = this._buffer.get(metric);\n    if (map == null) {\n      map = new AttributeHashMap();\n      this._buffer.set(metric, map);\n    }\n    if (metric._descriptor.valueType === metrics.ValueType.INT && !Number.isInteger(value)) {\n      api.diag.warn(\n        `INT value type cannot accept a floating-point value for ${metric._descriptor.name}, ignoring the fractional digits.`\n      );\n      value = Math.trunc(value);\n    }\n    map.set(attributes, value);\n  }\n}\n"]}