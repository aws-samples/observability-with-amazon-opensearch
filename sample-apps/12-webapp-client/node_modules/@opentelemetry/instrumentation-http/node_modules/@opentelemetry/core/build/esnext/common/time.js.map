{"version":3,"file":"time.js","sourceRoot":"","sources":["../../../src/common/time.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport { otperformance as performance } from '../platform';\nimport { TimeOriginLegacy } from './types';\n\nconst NANOSECOND_DIGITS = 9;\nconst SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);\n\n/**\n * Converts a number to HrTime, HrTime = [number, number].\n * The first number is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\n * The second number represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\n * numberToHrtime calculates the first number by converting and truncating the Epoch time in milliseconds to seconds:\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\n * numberToHrtime calculates the second number by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * SECOND_TO_NANOSECONDS = 150000000.\n * This is represented in HrTime format as [1609504210, 150000000].\n * @param epochMillis\n */\nfunction numberToHrtime(epochMillis: number): api.HrTime {\n  const epochSeconds = epochMillis / 1000;\n  // Decimals only.\n  const seconds = Math.trunc(epochSeconds);\n  // Round sub-nanosecond accuracy to nanosecond.\n  const nanos =\n    Number((epochSeconds - seconds).toFixed(NANOSECOND_DIGITS)) *\n    SECOND_TO_NANOSECONDS;\n  return [seconds, nanos];\n}\n\nfunction getTimeOrigin(): number {\n  let timeOrigin = performance.timeOrigin;\n  if (typeof timeOrigin !== 'number') {\n    const perf: TimeOriginLegacy = (performance as unknown) as TimeOriginLegacy;\n    timeOrigin = perf.timing && perf.timing.fetchStart;\n  }\n  return timeOrigin;\n}\n\n/**\n * Returns an hrtime calculated via performance component.\n * @param performanceNow\n */\nexport function hrTime(performanceNow?: number): api.HrTime {\n  const timeOrigin = numberToHrtime(getTimeOrigin());\n  const now = numberToHrtime(\n    typeof performanceNow === 'number' ? performanceNow : performance.now()\n  );\n\n  let seconds = timeOrigin[0] + now[0];\n  let nanos = timeOrigin[1] + now[1];\n\n  // Nanoseconds\n  if (nanos > SECOND_TO_NANOSECONDS) {\n    nanos -= SECOND_TO_NANOSECONDS;\n    seconds += 1;\n  }\n\n  return [seconds, nanos];\n}\n\n/**\n *\n * Converts a TimeInput to an HrTime, defaults to _hrtime().\n * @param time\n */\nexport function timeInputToHrTime(time: api.TimeInput): api.HrTime {\n  // process.hrtime\n  if (isTimeInputHrTime(time)) {\n    return time as api.HrTime;\n  } else if (typeof time === 'number') {\n    // Must be a performance.now() if it's smaller than process start time.\n    if (time < getTimeOrigin()) {\n      return hrTime(time);\n    } else {\n      // epoch milliseconds or performance.timeOrigin\n      return numberToHrtime(time);\n    }\n  } else if (time instanceof Date) {\n    return numberToHrtime(time.getTime());\n  } else {\n    throw TypeError('Invalid input type');\n  }\n}\n\n/**\n * Returns a duration of two hrTime.\n * @param startTime\n * @param endTime\n */\nexport function hrTimeDuration(\n  startTime: api.HrTime,\n  endTime: api.HrTime\n): api.HrTime {\n  let seconds = endTime[0] - startTime[0];\n  let nanos = endTime[1] - startTime[1];\n\n  // overflow\n  if (nanos < 0) {\n    seconds -= 1;\n    // negate\n    nanos += SECOND_TO_NANOSECONDS;\n  }\n\n  return [seconds, nanos];\n}\n\n/**\n * Convert hrTime to timestamp, for example \"2019-05-14T17:00:00.000123456Z\"\n * @param time\n */\nexport function hrTimeToTimeStamp(time: api.HrTime): string {\n  const precision = NANOSECOND_DIGITS;\n  const tmp = `${'0'.repeat(precision)}${time[1]}Z`;\n  const nanoString = tmp.substr(tmp.length - precision - 1);\n  const date = new Date(time[0] * 1000).toISOString();\n  return date.replace('000Z', nanoString);\n}\n\n/**\n * Convert hrTime to nanoseconds.\n * @param time\n */\nexport function hrTimeToNanoseconds(time: api.HrTime): number {\n  return time[0] * SECOND_TO_NANOSECONDS + time[1];\n}\n\n/**\n * Convert hrTime to milliseconds.\n * @param time\n */\nexport function hrTimeToMilliseconds(time: api.HrTime): number {\n  return Math.round(time[0] * 1e3 + time[1] / 1e6);\n}\n\n/**\n * Convert hrTime to microseconds.\n * @param time\n */\nexport function hrTimeToMicroseconds(time: api.HrTime): number {\n  return Math.round(time[0] * 1e6 + time[1] / 1e3);\n}\n\n/**\n * check if time is HrTime\n * @param value\n */\nexport function isTimeInputHrTime(value: unknown): value is api.HrTime {\n  return (\n    Array.isArray(value) &&\n    value.length === 2 &&\n    typeof value[0] === 'number' &&\n    typeof value[1] === 'number'\n  );\n}\n\n/**\n * check if input value is a correct types.TimeInput\n * @param value\n */\nexport function isTimeInput(value: unknown): value is api.HrTime | number | Date {\n  return (\n    isTimeInputHrTime(value) ||\n    typeof value === 'number' ||\n    value instanceof Date\n  );\n}\n"]}