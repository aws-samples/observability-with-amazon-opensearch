import { __assign } from "tslib";
import { cloneDeep } from '../utils';
import { getDefaultState, getMode, getReference, isModeValue, isReference } from './utils';
export function resolveTheme(theme) {
    return resolveThemeWithPaths(theme).resolvedTheme;
}
export function resolveThemeWithPaths(theme) {
    var resolvedTheme = {};
    var resolutionPaths = {};
    Object.keys(theme.tokens).forEach(function (token) {
        var mode = getMode(theme, token);
        if (mode) {
            resolutionPaths[token] = {};
            resolvedTheme[token] = Object.keys(mode.states).reduce(function (acc, state) {
                resolutionPaths[token][state] = [];
                acc[state] = resolveToken(theme, token, resolutionPaths[token][state], state);
                return acc;
            }, {});
        }
        else {
            resolutionPaths[token] = [];
            resolvedTheme[token] = resolveToken(theme, token, resolutionPaths[token]);
        }
    });
    return { resolvedTheme: resolvedTheme, resolutionPaths: resolutionPaths };
}
function resolveToken(theme, token, path, state) {
    if (!theme.tokens[token]) {
        throw new Error("Token ".concat(token, " does not exist in the theme."));
    }
    if (path.indexOf(token) !== -1) {
        throw new Error("Token ".concat(token, " has a circular dependency."));
    }
    path.push(token);
    var assignment = theme.tokens[token];
    if (isModeValue(assignment)) {
        if (!state) {
            throw new Error('Mode resolution needs state');
        }
        assignment = assignment[state];
    }
    if (isReference(assignment)) {
        var ref = getReference(assignment);
        return resolveToken(theme, ref, path, state);
    }
    else {
        return assignment;
    }
}
export function resolveContext(theme, context) {
    var tmp = cloneDeep(theme);
    tmp.tokens = __assign(__assign({}, tmp.tokens), context.tokens);
    return resolveTheme(tmp);
}
export function reduce(resolution, theme, reducer) {
    return Object.keys(resolution).reduce(function (acc, token) {
        var reduced = reducer(resolution[token], token, theme);
        if (reduced) {
            acc[token] = reduced;
        }
        return acc;
    }, {});
}
export var defaultsReducer = function () { return function (tokenResolution, token, theme) {
    var mode = getMode(theme, token);
    if (mode && isModeTokenResolution(tokenResolution)) {
        var defaultState = getDefaultState(mode);
        return tokenResolution[defaultState];
    }
    else if (isSpecificTokenResolution(tokenResolution)) {
        return tokenResolution;
    }
    else {
        throw new Error("Mismatch between resolution ".concat(tokenResolution, " and mode ").concat(mode));
    }
}; };
export var modeReducer = function (mode, state) {
    return function (tokenResolution, token, theme) {
        var tokenMode = getMode(theme, token);
        if (tokenMode && tokenMode.id === mode.id && isModeTokenResolution(tokenResolution)) {
            return tokenResolution[state];
        }
        else if (isSpecificTokenResolution(tokenResolution)) {
            return tokenResolution;
        }
    };
};
export function difference(base, other) {
    var result = {};
    Object.keys(other).forEach(function (token) {
        var baseVal = base[token];
        var otherVal = other[token];
        if (isSpecificTokenResolution(baseVal) && isSpecificTokenResolution(otherVal) && baseVal !== otherVal) {
            result[token] = otherVal;
        }
        else if (isModeTokenResolution(baseVal) && isModeTokenResolution(otherVal)) {
            var resolved = Object.keys(otherVal).reduce(function (acc, state) {
                if (baseVal[state] !== otherVal[state]) {
                    acc[state] = otherVal[state];
                }
                return acc;
            }, {});
            if (!isEmpty(resolved)) {
                result[token] = resolved;
            }
        }
    });
    return result;
}
export function isModeTokenResolution(val) {
    return typeof val === 'object';
}
export function isSpecificTokenResolution(val) {
    return typeof val === 'string';
}
var isEmpty = function (obj) { return Object.keys(obj).length === 0; };
