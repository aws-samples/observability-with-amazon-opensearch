{"version":3,"file":"sticky-scrolling.js","sourceRoot":"","sources":["../../../src/table/sticky-scrolling.ts"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,sCAAsC;AACtC,OAAO,EAAE,kBAAkB,EAAE,MAAM,yCAAyC,CAAC;AAE7E;;;;;GAKG;AACH,MAAM,CAAC,OAAO,UAAU,eAAe,CACrC,YAAwD,EACxD,SAAqD;IAErD,IAAM,WAAW,GAAG;QAClB,IAAI,CAAC,YAAY,CAAC,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE;YAC/C,OAAO;SACR;QACD,IAAM,eAAe,GAAG,wBAAwB,CAAC,YAAY,CAAC,OAAO,EAAE,SAAS,CAAC,OAAO,CAAC,CAAC;QAC1F,IAAI,eAAe,GAAG,CAAC,EAAE;YACvB,UAAU,CAAC,eAAe,EAAE,YAAY,CAAC,OAAO,CAAC,CAAC;SACnD;IACH,CAAC,CAAC;IACF,IAAM,YAAY,GAAG,UAAC,IAAwB;QAC5C,IAAI,CAAC,IAAI,IAAI,CAAC,YAAY,CAAC,OAAO,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE;YACxD,OAAO;SACR;QACD,IAAM,YAAY,GAAG,SAAS,CAAC,OAAO,CAAC,qBAAqB,EAAE,CAAC,MAAM,CAAC;QACtE,IAAM,eAAe,GAAG,YAAY,GAAG,IAAI,CAAC,qBAAqB,EAAE,CAAC,GAAG,CAAC;QACxE,IAAI,eAAe,GAAG,CAAC,EAAE;YACvB,UAAU,CAAC,eAAe,EAAE,YAAY,CAAC,OAAO,CAAC,CAAC;SACnD;IACH,CAAC,CAAC;IACF,OAAO;QACL,WAAW,aAAA;QACX,YAAY,cAAA;KACb,CAAC;AACJ,CAAC;AAED;;;;;;;GAOG;AACH,MAAM,UAAU,wBAAwB,CAAC,SAAsB,EAAE,MAAmB;IAClF,IAAM,UAAU,GAAG,MAAM,CAAC,qBAAqB,EAAE,CAAC;IAClD,IAAM,aAAa,GAAG,SAAS,CAAC,qBAAqB,EAAE,CAAC;IACxD,OAAO,UAAU,CAAC,GAAG,GAAG,aAAa,CAAC,GAAG,CAAC;AAC5C,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,UAAU,CAAC,MAAc,EAAE,SAAsB;IAC/D,IAAM,MAAM,GAAG,kBAAkB,CAAC,SAAS,CAAC,CAAC;IAC7C,IAAI,MAAM,CAAC,MAAM,EAAE;QACjB,qCAAqC;QACrC,MAAM,CAAC,CAAC,CAAC,CAAC,SAAS,IAAI,MAAM,CAAC;KAC/B;SAAM;QACL,MAAM,CAAC,QAAQ,CAAC,EAAE,GAAG,EAAE,MAAM,CAAC,WAAW,GAAG,MAAM,EAAE,CAAC,CAAC;KACvD;AACH,CAAC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\n\n/**\n * @param containerRef ref to surrounding container with sticky element\n * @param stickyRef ref to sticky element scrolled inside of containerRef\n * @param containerOffset offset between header and container\n *                        originating borders or paddings\n */\nexport default function stickyScrolling(\n  containerRef: React.MutableRefObject<HTMLElement | null>,\n  stickyRef: React.MutableRefObject<HTMLElement | null>\n) {\n  const scrollToTop = () => {\n    if (!containerRef.current || !stickyRef.current) {\n      return;\n    }\n    const scrollingOffset = calculateScrollingOffset(containerRef.current, stickyRef.current);\n    if (scrollingOffset > 0) {\n      scrollUpBy(scrollingOffset, containerRef.current);\n    }\n  };\n  const scrollToItem = (item: HTMLElement | null) => {\n    if (!item || !containerRef.current || !stickyRef.current) {\n      return;\n    }\n    const stickyBottom = stickyRef.current.getBoundingClientRect().bottom;\n    const scrollingOffset = stickyBottom - item.getBoundingClientRect().top;\n    if (scrollingOffset > 0) {\n      scrollUpBy(scrollingOffset, containerRef.current);\n    }\n  };\n  return {\n    scrollToTop,\n    scrollToItem,\n  };\n}\n\n/**\n * Calculates the scrolling offset between container and\n * sticky element with container offset caused by border\n * or padding\n * @param container\n * @param sticky element inside of container\n * @param containerOffset caused by borders or paddings\n */\nexport function calculateScrollingOffset(container: HTMLElement, sticky: HTMLElement) {\n  const stickyRect = sticky.getBoundingClientRect();\n  const containerRect = container.getBoundingClientRect();\n  return stickyRect.top - containerRect.top;\n}\n\n/**\n * Scrolls suitable parent of container up by amount of pixels\n * @param amount pixels to be scrolled up\n * @param container used to determine next parent element for scrolling\n */\nexport function scrollUpBy(amount: number, container: HTMLElement) {\n  const parent = getOverflowParents(container);\n  if (parent.length) {\n    // Take next overflow parent in stack\n    parent[0].scrollTop -= amount;\n  } else {\n    window.scrollTo({ top: window.pageYOffset - amount });\n  }\n}\n"]}