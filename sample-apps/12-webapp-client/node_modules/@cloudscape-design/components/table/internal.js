import { __assign, __rest } from "tslib";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import clsx from 'clsx';
import React, { useImperativeHandle, useRef } from 'react';
import InternalContainer from '../container/internal';
import { getBaseProps } from '../internal/base-component';
import ToolsHeader from './tools-header';
import Thead from './thead';
import { TableBodyCell, TableBodyCellContent } from './body-cell';
import InternalStatusIndicator from '../status-indicator/internal';
import { useContainerQuery } from '../internal/hooks/container-queries';
import { supportsStickyPosition } from '../internal/utils/dom';
import SelectionControl from './selection-control';
import { checkSortingState, getColumnKey, getItemKey, toContainerVariant } from './utils';
import { useRowEvents } from './use-row-events';
import { focusMarkers, useFocusMove, useSelection } from './use-selection';
import { fireNonCancelableEvent } from '../internal/events';
import { isDevelopment } from '../internal/is-development';
import { checkColumnWidths, ColumnWidthsProvider, DEFAULT_WIDTH } from './use-column-widths';
import { useScrollSync } from '../internal/hooks/use-scroll-sync';
import { ResizeTracker } from './resizer';
import styles from './styles.css.js';
import { useVisualRefresh } from '../internal/hooks/use-visual-mode';
import StickyHeader from './sticky-header';
import StickyScrollbar from './sticky-scrollbar';
import useFocusVisible from '../internal/hooks/focus-visible';
import { useMergeRefs } from '../internal/hooks/use-merge-refs';
var InternalTable = React.forwardRef(function (_a, ref) {
    var _b;
    var header = _a.header, footer = _a.footer, empty = _a.empty, filter = _a.filter, pagination = _a.pagination, preferences = _a.preferences, items = _a.items, columnDefinitions = _a.columnDefinitions, trackBy = _a.trackBy, loading = _a.loading, loadingText = _a.loadingText, selectionType = _a.selectionType, selectedItems = _a.selectedItems, isItemDisabled = _a.isItemDisabled, ariaLabels = _a.ariaLabels, onSelectionChange = _a.onSelectionChange, onSortingChange = _a.onSortingChange, sortingColumn = _a.sortingColumn, sortingDescending = _a.sortingDescending, sortingDisabled = _a.sortingDisabled, visibleColumns = _a.visibleColumns, stickyHeader = _a.stickyHeader, stickyHeaderVerticalOffset = _a.stickyHeaderVerticalOffset, onRowClick = _a.onRowClick, onRowContextMenu = _a.onRowContextMenu, wrapLines = _a.wrapLines, resizableColumns = _a.resizableColumns, onColumnWidthsChange = _a.onColumnWidthsChange, variant = _a.variant, __internalRootRef = _a.__internalRootRef, rest = __rest(_a, ["header", "footer", "empty", "filter", "pagination", "preferences", "items", "columnDefinitions", "trackBy", "loading", "loadingText", "selectionType", "selectedItems", "isItemDisabled", "ariaLabels", "onSelectionChange", "onSortingChange", "sortingColumn", "sortingDescending", "sortingDisabled", "visibleColumns", "stickyHeader", "stickyHeaderVerticalOffset", "onRowClick", "onRowContextMenu", "wrapLines", "resizableColumns", "onColumnWidthsChange", "variant", "__internalRootRef"]);
    var baseProps = getBaseProps(rest);
    stickyHeader = stickyHeader && supportsStickyPosition();
    var _c = useContainerQuery(function (_a) {
        var width = _a.width;
        return width;
    }), containerWidth = _c[0], wrapperMeasureRef = _c[1];
    var wrapperRefObject = useRef(null);
    var wrapperRef = useMergeRefs(wrapperMeasureRef, wrapperRefObject);
    var _d = useContainerQuery(function (_a) {
        var width = _a.width;
        return width;
    }), tableWidth = _d[0], tableMeasureRef = _d[1];
    var tableRefObject = useRef(null);
    var tableRef = useMergeRefs(tableMeasureRef, tableRefObject);
    var secondaryWrapperRef = React.useRef(null);
    var theadRef = useRef(null);
    var stickyHeaderRef = React.useRef(null);
    var scrollbarRef = React.useRef(null);
    useImperativeHandle(ref, function () { var _a; return ({ scrollToTop: ((_a = stickyHeaderRef.current) === null || _a === void 0 ? void 0 : _a.scrollToTop) || (function () { return undefined; }) }); });
    var handleScroll = useScrollSync([wrapperRefObject, scrollbarRef, secondaryWrapperRef], !supportsStickyPosition());
    var _e = useFocusMove(selectionType, items.length), moveFocusDown = _e.moveFocusDown, moveFocusUp = _e.moveFocusUp, moveFocus = _e.moveFocus;
    var _f = useRowEvents({ onRowClick: onRowClick, onRowContextMenu: onRowContextMenu }), onRowClickHandler = _f.onRowClickHandler, onRowContextMenuHandler = _f.onRowContextMenuHandler;
    var visibleColumnDefinitions = visibleColumns
        ? columnDefinitions.filter(function (column) { return column.id && visibleColumns.indexOf(column.id) !== -1; })
        : columnDefinitions;
    var _g = useSelection({
        items: items,
        trackBy: trackBy,
        selectedItems: selectedItems,
        selectionType: selectionType,
        isItemDisabled: isItemDisabled,
        onSelectionChange: onSelectionChange,
        ariaLabels: ariaLabels
    }), isItemSelected = _g.isItemSelected, selectAllProps = _g.selectAllProps, getItemSelectionProps = _g.getItemSelectionProps, updateShiftToggle = _g.updateShiftToggle;
    if (loading) {
        selectAllProps.disabled = true;
    }
    if (isDevelopment) {
        if (resizableColumns) {
            checkColumnWidths(columnDefinitions);
        }
        if (sortingColumn === null || sortingColumn === void 0 ? void 0 : sortingColumn.sortingComparator) {
            checkSortingState(columnDefinitions, sortingColumn.sortingComparator);
        }
    }
    var isRefresh = useVisualRefresh(tableRefObject);
    var computedVariant = isRefresh
        ? variant
        : ['embedded', 'full-page'].indexOf(variant) > -1
            ? 'container'
            : variant;
    var hasHeader = !!(header || filter || pagination || preferences);
    var theadProps = {
        containerWidth: containerWidth,
        selectionType: selectionType,
        selectAllProps: selectAllProps,
        columnDefinitions: visibleColumnDefinitions,
        variant: computedVariant,
        wrapLines: wrapLines,
        resizableColumns: resizableColumns,
        sortingColumn: sortingColumn,
        sortingDisabled: sortingDisabled,
        sortingDescending: sortingDescending,
        onSortingChange: onSortingChange,
        onFocusMove: moveFocus,
        onResizeFinish: function (newWidth) {
            var widthsDetail = columnDefinitions.map(function (column, index) { return newWidth[getColumnKey(column, index)] || column.width || DEFAULT_WIDTH; });
            var widthsChanged = widthsDetail.some(function (width, index) { return columnDefinitions[index].width !== width; });
            if (widthsChanged) {
                fireNonCancelableEvent(onColumnWidthsChange, { widths: widthsDetail });
            }
        }
    };
    // Allows keyboard users to scroll horizontally with arrow keys by making the wrapper part of the tab sequence
    var isWrapperScrollable = tableWidth && containerWidth && tableWidth > containerWidth;
    var wrapperProps = isWrapperScrollable
        ? { role: 'region', tabIndex: 0, 'aria-label': ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tableLabel }
        : {};
    var focusVisibleProps = useFocusVisible();
    return (React.createElement(ColumnWidthsProvider, { tableRef: tableRefObject, visibleColumnDefinitions: visibleColumnDefinitions, resizableColumns: resizableColumns, hasSelection: !!selectionType },
        React.createElement(InternalContainer, __assign({}, baseProps, { __internalRootRef: __internalRootRef, className: clsx(baseProps.className, styles.root), header: React.createElement(React.Fragment, null,
                hasHeader && (React.createElement("div", { className: clsx(styles['header-controls'], styles["variant-".concat(computedVariant)]) },
                    React.createElement(ToolsHeader, { header: header, filter: filter, pagination: pagination, preferences: preferences }))),
                stickyHeader && (React.createElement(StickyHeader, { ref: stickyHeaderRef, variant: computedVariant, theadProps: theadProps, wrapperRef: wrapperRefObject, theadRef: theadRef, secondaryWrapperRef: secondaryWrapperRef, tableRef: tableRefObject, onScroll: handleScroll }))), disableHeaderPaddings: true, disableContentPaddings: true, variant: toContainerVariant(computedVariant), __disableFooterPaddings: true, __disableFooterDivider: true, footer: footer && (React.createElement("div", { className: clsx(styles['footer-wrapper'], styles["variant-".concat(computedVariant)]) },
                React.createElement("hr", { className: styles.divider }),
                React.createElement("div", { className: styles.footer }, footer))), __stickyHeader: stickyHeader, __stickyOffset: stickyHeaderVerticalOffset }, focusMarkers.root),
            React.createElement("div", __assign({ ref: wrapperRef, className: clsx(styles.wrapper, styles["variant-".concat(computedVariant)], (_b = {},
                    _b[styles['has-footer']] = !!footer,
                    _b[styles['has-header']] = hasHeader,
                    _b)), onScroll: handleScroll }, wrapperProps, focusVisibleProps),
                React.createElement("table", { ref: tableRef, className: clsx(styles.table, resizableColumns && styles['table-layout-fixed']), 
                    // Browsers have weird mechanism to guess whether it's a data table or a layout table.
                    // If we state explicitly, they get it always correctly even with low number of rows.
                    role: "table", "aria-label": ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tableLabel },
                    React.createElement(Thead, __assign({ ref: theadRef, hidden: stickyHeader, onCellFocus: function (colIndex) { var _a; return (_a = stickyHeaderRef.current) === null || _a === void 0 ? void 0 : _a.setFocusedColumn(colIndex); }, onCellBlur: function () { var _a; return (_a = stickyHeaderRef.current) === null || _a === void 0 ? void 0 : _a.setFocusedColumn(null); } }, theadProps)),
                    React.createElement("tbody", null, loading || items.length === 0 ? (React.createElement("tr", null,
                        React.createElement("td", { colSpan: selectionType ? visibleColumnDefinitions.length + 1 : visibleColumnDefinitions.length, className: styles['cell-merged'] },
                            React.createElement("div", { className: styles['cell-merged-content'], style: {
                                    width: (supportsStickyPosition() && containerWidth && Math.floor(containerWidth)) || undefined
                                } }, loading ? (React.createElement(InternalStatusIndicator, { type: "loading", className: styles.loading, wrapText: true }, loadingText)) : (React.createElement("div", { className: styles.empty }, empty)))))) : (items.map(function (item, rowIndex) {
                        var firstVisible = rowIndex === 0;
                        var lastVisible = rowIndex === items.length - 1;
                        var isSelected = !!selectionType && isItemSelected(item);
                        var isPrevSelected = !!selectionType && !firstVisible && isItemSelected(items[rowIndex - 1]);
                        var isNextSelected = !!selectionType && !lastVisible && isItemSelected(items[rowIndex + 1]);
                        return (React.createElement("tr", __assign({ key: getItemKey(trackBy, item, rowIndex), className: clsx(styles.row, isSelected && styles['row-selected']), onFocus: function (_a) {
                                var _b;
                                var currentTarget = _a.currentTarget;
                                return (_b = stickyHeaderRef.current) === null || _b === void 0 ? void 0 : _b.scrollToRow(currentTarget);
                            } }, focusMarkers.item, { onClick: onRowClickHandler && onRowClickHandler.bind(null, rowIndex, item), onContextMenu: onRowContextMenuHandler && onRowContextMenuHandler.bind(null, rowIndex, item) }),
                            selectionType !== undefined && (React.createElement(TableBodyCell, { className: styles['selection-control'], isFirstRow: firstVisible, isLastRow: lastVisible, isSelected: isSelected, isNextSelected: isNextSelected, isPrevSelected: isPrevSelected, wrapLines: false },
                                React.createElement(SelectionControl, __assign({ onFocusDown: moveFocusDown, onFocusUp: moveFocusUp, onShiftToggle: updateShiftToggle }, getItemSelectionProps(item))))),
                            visibleColumnDefinitions.map(function (column, colIndex) { return (React.createElement(TableBodyCellContent, { key: getColumnKey(column, colIndex), style: resizableColumns
                                    ? {}
                                    : {
                                        width: column.width,
                                        minWidth: column.minWidth,
                                        maxWidth: column.maxWidth
                                    }, column: column, item: item, wrapLines: wrapLines, isFirstRow: firstVisible, isLastRow: lastVisible, isSelected: isSelected, isNextSelected: isNextSelected, isPrevSelected: isPrevSelected })); })));
                    })))),
                resizableColumns && React.createElement(ResizeTracker, null)),
            React.createElement(StickyScrollbar, { ref: scrollbarRef, wrapperRef: wrapperRefObject, tableRef: tableRefObject, onScroll: handleScroll }))));
});
export default InternalTable;
//# sourceMappingURL=internal.js.map