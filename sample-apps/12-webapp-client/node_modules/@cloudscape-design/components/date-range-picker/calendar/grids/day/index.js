import { __assign } from "tslib";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React from 'react';
import styles from './styles.css.js';
import { getDaysInMonth, isAfter, isBefore, isLastDayOfMonth, isSameMonth, isToday as isTodayFn } from 'date-fns';
import { getDateLabel } from '../../../../date-picker/calendar/utils/intl';
import clsx from 'clsx';
import { KeyCode } from '../../../../internal/keycode.js';
import { formatDate } from '../../../../date-picker/calendar/utils/date.js';
import useFocusVisible from '../../../../internal/hooks/focus-visible';
function propsAreEqual(prevProps, nextProps) {
    return (prevProps.locale === nextProps.locale &&
        prevProps.baseDate.getTime() === nextProps.baseDate.getTime() &&
        prevProps.date.getTime() === nextProps.date.getTime() &&
        prevProps.isDateInFirstRow === nextProps.isDateInFirstRow &&
        prevProps.isDateInFirstColumn === nextProps.isDateInFirstColumn &&
        prevProps.isDateInLastColumn === nextProps.isDateInLastColumn &&
        prevProps.isDateInSelectionStartWeek === nextProps.isDateInSelectionStartWeek &&
        prevProps.isDateInSelectionEndWeek === nextProps.isDateInSelectionEndWeek &&
        prevProps.isFocusedDate === nextProps.isFocusedDate &&
        prevProps.isDateEnabled === nextProps.isDateEnabled &&
        prevProps.todayAriaLabel === nextProps.todayAriaLabel &&
        prevProps.onSelectDate === nextProps.onSelectDate &&
        prevProps.onFocusDate === nextProps.onFocusDate &&
        prevProps.isInRange === nextProps.isInRange &&
        prevProps.isSelected === nextProps.isSelected &&
        prevProps.isStartDate === nextProps.isStartDate &&
        prevProps.isEndDate === nextProps.isEndDate &&
        prevProps.onlyOneSelected === nextProps.onlyOneSelected &&
        prevProps.isRangeStartDate === nextProps.isRangeStartDate &&
        prevProps.isRangeEndDate === nextProps.isRangeEndDate);
}
var GridDay = React.memo(React.forwardRef(function (_a, ref) {
    var _b, _c, _d;
    var locale = _a.locale, baseDate = _a.baseDate, date = _a.date, isSelected = _a.isSelected, isStartDate = _a.isStartDate, isEndDate = _a.isEndDate, onlyOneSelected = _a.onlyOneSelected, isRangeStartDate = _a.isRangeStartDate, isRangeEndDate = _a.isRangeEndDate, isFocusedDate = _a.isFocusedDate, isDateEnabled = _a.isDateEnabled, todayAriaLabel = _a.todayAriaLabel, onSelectDate = _a.onSelectDate, onFocusDate = _a.onFocusDate, isDateInFirstRow = _a.isDateInFirstRow, isDateInFirstColumn = _a.isDateInFirstColumn, isDateInLastColumn = _a.isDateInLastColumn, isDateInSelectionStartWeek = _a.isDateInSelectionStartWeek, isDateInSelectionEndWeek = _a.isDateInSelectionEndWeek, isInRange = _a.isInRange;
    var dayLabel = getDateLabel(locale, date);
    var labels = [dayLabel];
    var isEnabled = !isDateEnabled || isDateEnabled(date);
    var isFocusable = isFocusedDate && isEnabled;
    var isToday = isTodayFn(date);
    var computedAttributes = {};
    var focusVisible = useFocusVisible();
    var baseClasses = (_b = {},
        _b[styles['in-first-row']] = isDateInFirstRow,
        _b[styles['in-first-column']] = isDateInFirstColumn,
        _b);
    if (!isSameMonth(date, baseDate)) {
        var classNames_1 = clsx(styles.day, baseClasses, (_c = {},
            _c[styles['in-previous-month']] = isBefore(date, baseDate),
            _c[styles['last-day-of-month']] = isLastDayOfMonth(date),
            _c[styles['in-next-month']] = isAfter(date, baseDate),
            _c));
        return React.createElement("div", { className: classNames_1, ref: ref });
    }
    var classNames = clsx(styles.day, baseClasses, (_d = {},
        _d[styles['in-current-month']] = isSameMonth(date, baseDate),
        _d[styles.enabled] = isEnabled,
        _d[styles.selected] = isSelected,
        _d[styles['start-date']] = isStartDate,
        _d[styles['end-date']] = isEndDate,
        _d[styles['range-start-date']] = isRangeStartDate,
        _d[styles['range-end-date']] = isRangeEndDate,
        _d[styles['no-range']] = isSelected && onlyOneSelected,
        _d[styles['in-range']] = isInRange,
        _d[styles['in-range-border-top']] = isDateInSelectionStartWeek || date.getDate() <= 7,
        _d[styles['in-range-border-bottom']] = isDateInSelectionEndWeek || date.getDate() > getDaysInMonth(date) - 7,
        _d[styles['in-range-border-left']] = isDateInFirstColumn || date.getDate() === 1 || isRangeStartDate,
        _d[styles['in-range-border-right']] = isDateInLastColumn || isLastDayOfMonth(date) || isRangeEndDate,
        _d[styles.today] = isToday,
        _d));
    computedAttributes['aria-pressed'] = isSelected || isInRange;
    if (isToday) {
        labels.push(todayAriaLabel);
        computedAttributes['aria-current'] = 'date';
    }
    if (isEnabled) {
        computedAttributes.onClick = function () { return onSelectDate(date); };
        computedAttributes.onFocus = function () { return onFocusDate(date); };
        computedAttributes.tabIndex = -1;
    }
    if (isFocusable) {
        computedAttributes.tabIndex = 0;
    }
    var onKeyDown = function (event) {
        if (event.keyCode === KeyCode.space) {
            event.preventDefault();
            onSelectDate(date);
        }
    };
    return (React.createElement("div", __assign({ className: classNames, "aria-label": labels.join('. '), "data-date": formatDate(date), role: "button" }, computedAttributes, { ref: ref, onKeyDown: onKeyDown }, focusVisible),
        React.createElement("span", { className: styles['day-inner'] }, date.getDate())));
}), propsAreEqual);
export default GridDay;
//# sourceMappingURL=index.js.map