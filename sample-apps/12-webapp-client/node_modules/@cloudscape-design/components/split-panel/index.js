import { __assign, __rest } from "tslib";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useState, useEffect, useLayoutEffect, useRef } from 'react';
import clsx from 'clsx';
import { InternalButton } from '../button/internal';
import { getBaseProps } from '../internal/base-component';
import { useSplitPanelContext } from '../internal/context/split-panel-context';
import useFocusVisible from '../internal/hooks/focus-visible';
import { applyDisplayName } from '../internal/utils/apply-display-name';
import ResizeHandler from './icons/resize-handler';
import PreferencesModal from './preferences-modal';
import { useMouseEvents } from './utils/use-mouse-events';
import { useKeyboardEvents } from './utils/use-keyboard-events';
import styles from './styles.css.js';
import useBaseComponent from '../internal/hooks/use-base-component';
import { useMergeRefs } from '../internal/hooks/use-merge-refs';
import { AppLayoutContext } from '../internal/context/app-layout-context';
import { getLimitedValue } from './utils/size-utils';
import { Transition } from '../internal/components/transition';
import { useEffectOnUpdate } from '../internal/hooks/use-effect-on-update';
var MIN_HEIGHT = 160;
var MIN_WIDTH = 280;
var TransitionContentSide = function (_a) {
    var _b, _c;
    var baseProps = _a.baseProps, isOpen = _a.isOpen, splitPanelRef = _a.splitPanelRef, topOffset = _a.topOffset, bottomOffset = _a.bottomOffset, cappedSize = _a.cappedSize, isRefresh = _a.isRefresh, onToggle = _a.onToggle, i18nStrings = _a.i18nStrings, relativeSize = _a.relativeSize, onKeyDown = _a.onKeyDown, onSliderMouseDown = _a.onSliderMouseDown, focusVisible = _a.focusVisible, toggleRef = _a.toggleRef, paneHeader = _a.paneHeader, wrappedChildren = _a.wrappedChildren;
    return (React.createElement("div", __assign({}, baseProps, { className: clsx(baseProps.className, styles.drawer, styles.root, styles['position-side'], (_b = {},
            _b[styles['drawer-closed']] = !isOpen,
            _b)), ref: splitPanelRef }),
        React.createElement("aside", { style: {
                top: topOffset,
                bottom: bottomOffset,
                width: isOpen ? cappedSize : undefined,
                maxWidth: isRefresh ? '100%' : undefined
            }, className: clsx(styles['drawer-content-side'], (_c = {},
                _c[styles.refresh] = isRefresh,
                _c)), onClick: function () { return !isOpen && onToggle(); } },
            isOpen ? (React.createElement("div", { className: styles['slider-wrapper-side'] },
                React.createElement("div", __assign({ role: "slider", tabIndex: 0, "aria-label": i18nStrings.resizeHandleAriaLabel, "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": relativeSize, className: clsx(styles.slider, styles['slider-side']), onKeyDown: onKeyDown, onMouseDown: onSliderMouseDown }, focusVisible),
                    React.createElement(ResizeHandler, { className: clsx(styles['slider-icon'], styles['slider-icon-side']) })))) : (React.createElement(InternalButton, { className: clsx(styles['open-button'], styles['open-button-side']), iconName: "angle-left", variant: "icon", formAction: "none", ariaLabel: i18nStrings.openButtonAriaLabel, ref: isRefresh ? null : toggleRef })),
            React.createElement("div", { className: styles['content-side'], "aria-hidden": !isOpen },
                React.createElement("div", { className: clsx(styles['pane-header-wrapper-side']) }, paneHeader),
                React.createElement("hr", { className: styles['header-divider'] }),
                React.createElement("div", { className: clsx(styles['pane-content-wrapper-side']) }, wrappedChildren)))));
};
var TransitionContentBottom = function (_a) {
    var _b, _c;
    var baseProps = _a.baseProps, isOpen = _a.isOpen, splitPanelRef = _a.splitPanelRef, bottomOffset = _a.bottomOffset, cappedSize = _a.cappedSize, isRefresh = _a.isRefresh, onToggle = _a.onToggle, i18nStrings = _a.i18nStrings, relativeSize = _a.relativeSize, onKeyDown = _a.onKeyDown, onSliderMouseDown = _a.onSliderMouseDown, focusVisible = _a.focusVisible, paneHeader = _a.paneHeader, wrappedChildren = _a.wrappedChildren, isMobile = _a.isMobile, disableContentPaddings = _a.disableContentPaddings, state = _a.state, leftOffset = _a.leftOffset, rightOffset = _a.rightOffset, transitioningElementRef = _a.transitioningElementRef, centeredMaxWidthClasses = _a.centeredMaxWidthClasses, splitPanelHeaderRef = _a.splitPanelHeaderRef, appLayoutMaxWidth = _a.appLayoutMaxWidth;
    var transitionContentBottomRef = useMergeRefs(splitPanelRef || null, transitioningElementRef);
    return (React.createElement("div", __assign({}, baseProps, { className: clsx(baseProps.className, styles.root, styles.drawer, styles['position-bottom'], (_b = {},
            _b[styles['drawer-closed']] = !isOpen,
            _b[styles['drawer-mobile']] = isMobile,
            _b[styles['drawer-disable-content-paddings']] = disableContentPaddings,
            _b[styles.animating] = isRefresh && (state === 'entering' || state === 'exiting'),
            _b[styles.refresh] = isRefresh,
            _b)), onClick: function () { return !isOpen && onToggle(); }, style: {
            bottom: bottomOffset,
            left: leftOffset,
            right: rightOffset,
            height: isOpen ? cappedSize : undefined
        }, ref: transitionContentBottomRef }),
        isOpen && (React.createElement("div", { className: styles['slider-wrapper-bottom'] },
            React.createElement("div", __assign({ role: "slider", tabIndex: 0, "aria-label": i18nStrings.resizeHandleAriaLabel, "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": relativeSize, className: clsx(styles.slider, styles['slider-bottom']), onKeyDown: onKeyDown, onMouseDown: onSliderMouseDown }, focusVisible),
                React.createElement(ResizeHandler, { className: clsx(styles['slider-icon'], styles['slider-icon-bottom']) })))),
        React.createElement("div", { className: styles['drawer-content-bottom'] },
            React.createElement("div", { className: clsx(styles['pane-header-wrapper-bottom'], centeredMaxWidthClasses), ref: splitPanelHeaderRef }, paneHeader),
            React.createElement("div", { className: clsx(styles['content-bottom'], centeredMaxWidthClasses), "aria-hidden": !isOpen },
                React.createElement("div", { className: clsx((_c = {}, _c[styles['content-bottom-max-width']] = isRefresh, _c)), style: appLayoutMaxWidth }, wrappedChildren)))));
};
export default function SplitPanel(_a) {
    var _b;
    var header = _a.header, children = _a.children, _c = _a.hidePreferencesButton, hidePreferencesButton = _c === void 0 ? false : _c, i18nStrings = _a.i18nStrings, restProps = __rest(_a, ["header", "children", "hidePreferencesButton", "i18nStrings"]);
    var __internalRootRef = useBaseComponent('SplitPanel').__internalRootRef;
    var _d = useSplitPanelContext(), size = _d.size, getMaxWidth = _d.getMaxWidth, getMaxHeight = _d.getMaxHeight, position = _d.position, topOffset = _d.topOffset, bottomOffset = _d.bottomOffset, leftOffset = _d.leftOffset, rightOffset = _d.rightOffset, disableContentPaddings = _d.disableContentPaddings, contentWidthStyles = _d.contentWidthStyles, contentWrapperPaddings = _d.contentWrapperPaddings, isCopy = _d.isCopy, isOpen = _d.isOpen, isMobile = _d.isMobile, isRefresh = _d.isRefresh, isForcedPosition = _d.isForcedPosition, splitPanelRef = _d.splitPanelRef, splitPanelHeaderRef = _d.splitPanelHeaderRef, lastInteraction = _d.lastInteraction, onPreferencesChange = _d.onPreferencesChange, onResize = _d.onResize, onToggle = _d.onToggle, reportSize = _d.reportSize, setOpenButtonAriaLabel = _d.setOpenButtonAriaLabel;
    var baseProps = getBaseProps(restProps);
    var focusVisible = useFocusVisible();
    var _e = useState(false), isPreferencesOpen = _e[0], setPreferencesOpen = _e[1];
    var _f = useState(0), relativeSize = _f[0], setRelativeSize = _f[1];
    var _g = useState(size), maxSize = _g[0], setMaxSize = _g[1];
    var minSize = position === 'bottom' ? MIN_HEIGHT : MIN_WIDTH;
    var cappedSize = getLimitedValue(minSize, size, maxSize);
    var appLayoutMaxWidth = isRefresh && position === 'bottom' ? contentWidthStyles : undefined;
    useEffect(function () {
        setOpenButtonAriaLabel === null || setOpenButtonAriaLabel === void 0 ? void 0 : setOpenButtonAriaLabel(i18nStrings.openButtonAriaLabel);
    }, [setOpenButtonAriaLabel, i18nStrings.openButtonAriaLabel]);
    useEffect(function () {
        // effects are called inside out in the components tree
        // wait one frame to allow app-layout to complete its calculations
        var handle = requestAnimationFrame(function () {
            var maxSize = position === 'bottom' ? getMaxHeight() : getMaxWidth();
            setRelativeSize((size / maxSize) * 100);
            setMaxSize(maxSize);
        });
        return function () { return cancelAnimationFrame(handle); };
    }, [size, position, getMaxHeight, getMaxWidth]);
    useEffect(function () {
        reportSize(cappedSize);
    }, [reportSize, cappedSize]);
    useEffect(function () {
        var handler = function () { return setMaxSize(position === 'bottom' ? getMaxHeight() : getMaxWidth()); };
        window.addEventListener('resize', handler);
        return function () { return window.removeEventListener('resize', handler); };
    }, [position, getMaxWidth, getMaxHeight]);
    var setSidePanelWidth = function (width) {
        var maxWidth = getMaxWidth();
        var size = getLimitedValue(MIN_WIDTH, width, maxWidth);
        if (isOpen && maxWidth >= MIN_WIDTH) {
            onResize({ size: size });
        }
    };
    var setBottomPanelHeight = function (height) {
        var maxHeight = getMaxHeight();
        var size = getLimitedValue(MIN_HEIGHT, height, maxHeight);
        if (isOpen && maxHeight >= MIN_HEIGHT) {
            onResize({ size: size });
        }
    };
    var splitPanelRefObject = useRef(null);
    var sizeControlProps = {
        position: position,
        splitPanelRef: splitPanelRefObject,
        setSidePanelWidth: setSidePanelWidth,
        setBottomPanelHeight: setBottomPanelHeight
    };
    var onSliderMouseDown = useMouseEvents(sizeControlProps);
    var onKeyDown = useKeyboardEvents(sizeControlProps);
    var toggleRef = useRef(null);
    var closeRef = useRef(null);
    var preferencesRef = useRef(null);
    useEffectOnUpdate(function () {
        var _a, _b, _c;
        switch (lastInteraction === null || lastInteraction === void 0 ? void 0 : lastInteraction.type) {
            case 'open':
                return (_a = closeRef.current) === null || _a === void 0 ? void 0 : _a.focus();
            case 'close':
                return (_b = toggleRef.current) === null || _b === void 0 ? void 0 : _b.focus();
            case 'position':
                return (_c = preferencesRef.current) === null || _c === void 0 ? void 0 : _c.focus();
            default:
                return;
        }
    }, [lastInteraction]);
    var wrappedChildren = (React.createElement(AppLayoutContext.Provider, { value: {
            stickyOffsetTop: topOffset,
            stickyOffsetBottom: bottomOffset
        } }, children));
    var paneHeader = (React.createElement("div", { className: styles.header, style: appLayoutMaxWidth },
        React.createElement("h2", { className: styles['header-text'] }, header),
        React.createElement("div", { className: styles['header-actions'] },
            !hidePreferencesButton && isOpen && (React.createElement(React.Fragment, null,
                React.createElement(InternalButton, { className: styles['preferences-button'], iconName: "settings", variant: "icon", onClick: function () { return setPreferencesOpen(true); }, formAction: "none", ariaLabel: i18nStrings.preferencesTitle, ref: preferencesRef }),
                React.createElement("span", { className: styles.divider }))),
            isOpen ? (React.createElement(InternalButton, { className: styles['close-button'], iconName: isRefresh && position === 'side' ? 'angle-right' : isRefresh ? 'angle-down' : 'close', variant: "icon", onClick: onToggle, formAction: "none", ariaLabel: i18nStrings.closeButtonAriaLabel, ref: closeRef })) : position === 'side' ? null : (React.createElement(InternalButton, { className: styles['open-button'], iconName: "angle-up", variant: "icon", formAction: "none", ariaLabel: i18nStrings.openButtonAriaLabel, ref: toggleRef })))));
    /*
      This effect forces the browser to recalculate the layout
      whenever the split panel might have moved.
  
      This is needed as a workaround for a bug in Safari, which does
      not automatically calculate the new position of the split panel
      _content_ when the split panel moves.
    */
    useLayoutEffect(function () {
        var root = __internalRootRef.current;
        if (root) {
            var property = 'transform';
            var temporaryValue = 'translateZ(0)';
            var valueBefore = root.style[property];
            root.style[property] = temporaryValue;
            // This line forces the browser to recalculate the layout
            void root.offsetHeight;
            root.style[property] = valueBefore;
        }
    }, [rightOffset, __internalRootRef]);
    var mergedRef = useMergeRefs(splitPanelRef, splitPanelRefObject, __internalRootRef);
    /**
     * The AppLayout factor moved the circular buttons out of the
     * SplitPanel and into the Tools component. This conditional
     * is still needed for the early return to prevent execution
     * of the following code.
     */
    if (isRefresh && (!isOpen || isCopy) && position === 'side') {
        return React.createElement(React.Fragment, null);
    }
    var centeredMaxWidthClasses = clsx((_b = {},
        _b[styles['pane-bottom-center-align']] = isRefresh,
        _b[styles['pane-bottom-content-nav-padding']] = contentWrapperPaddings === null || contentWrapperPaddings === void 0 ? void 0 : contentWrapperPaddings.closedNav,
        _b[styles['pane-bottom-content-tools-padding']] = contentWrapperPaddings === null || contentWrapperPaddings === void 0 ? void 0 : contentWrapperPaddings.closedTools,
        _b));
    return (React.createElement(Transition, { "in": isOpen !== null && isOpen !== void 0 ? isOpen : false }, function (state, transitioningElementRef) { return (React.createElement(React.Fragment, null,
        position === 'side' && (React.createElement(TransitionContentSide, { baseProps: baseProps, isOpen: isOpen, splitPanelRef: mergedRef, topOffset: topOffset, bottomOffset: bottomOffset, cappedSize: cappedSize, isRefresh: isRefresh, onToggle: onToggle, i18nStrings: i18nStrings, relativeSize: relativeSize, onKeyDown: onKeyDown, onSliderMouseDown: onSliderMouseDown, focusVisible: focusVisible, toggleRef: toggleRef, paneHeader: paneHeader, wrappedChildren: wrappedChildren })),
        position === 'bottom' && (React.createElement(TransitionContentBottom, { baseProps: baseProps, isOpen: isOpen, splitPanelRef: mergedRef, bottomOffset: bottomOffset, cappedSize: cappedSize, isRefresh: isRefresh, onToggle: onToggle, i18nStrings: i18nStrings, relativeSize: relativeSize, onKeyDown: onKeyDown, onSliderMouseDown: onSliderMouseDown, focusVisible: focusVisible, paneHeader: paneHeader, wrappedChildren: wrappedChildren, isMobile: isMobile, disableContentPaddings: disableContentPaddings, state: state, leftOffset: leftOffset, rightOffset: rightOffset, transitioningElementRef: transitioningElementRef, centeredMaxWidthClasses: centeredMaxWidthClasses, splitPanelHeaderRef: splitPanelHeaderRef, appLayoutMaxWidth: appLayoutMaxWidth })),
        isPreferencesOpen && (React.createElement(PreferencesModal, { visible: true, preferences: { position: position }, disabledSidePosition: position === 'bottom' && isForcedPosition, isRefresh: isRefresh, i18nStrings: {
                header: i18nStrings.preferencesTitle,
                confirm: i18nStrings.preferencesConfirm,
                cancel: i18nStrings.preferencesCancel,
                positionLabel: i18nStrings.preferencesPositionLabel,
                positionDescription: i18nStrings.preferencesPositionDescription,
                positionBottom: i18nStrings.preferencesPositionBottom,
                positionSide: i18nStrings.preferencesPositionSide
            }, onConfirm: function (preferences) {
                onPreferencesChange(__assign({}, preferences));
                setPreferencesOpen(false);
            }, onDismiss: function () {
                setPreferencesOpen(false);
            } })))); }));
}
applyDisplayName(SplitPanel, 'SplitPanel');
//# sourceMappingURL=index.js.map