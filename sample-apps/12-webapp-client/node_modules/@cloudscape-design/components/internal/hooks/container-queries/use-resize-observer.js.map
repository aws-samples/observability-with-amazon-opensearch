{"version":3,"file":"use-resize-observer.js","sourceRoot":"","sources":["../../../../../src/internal/hooks/container-queries/use-resize-observer.ts"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,sCAAsC;AACtC,OAAO,EAAE,cAAc,EAAE,mBAAmB,EAAE,MAAM,yBAAyB,CAAC;AAC9E,OAAc,EAAE,SAAS,EAAE,eAAe,EAAE,MAAM,OAAO,CAAC;AAC1D,OAAO,EAAE,qBAAqB,EAAE,MAAM,6BAA6B,CAAC;AAKpE;;;;;;;;;;;;;;GAcG;AACH,MAAM,UAAU,iBAAiB,CAAC,UAA4B,EAAE,SAA+C;IAC7G,IAAM,eAAe,GAAG,qBAAqB,CAAC,SAAS,CAAC,CAAC;IAEzD,qIAAqI;IACrI,+GAA+G;IAC/G,iIAAiI;IACjI,eAAe,CACb;QACE,IAAM,OAAO,GAAG,OAAO,UAAU,KAAK,UAAU,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,OAAO,CAAC;QACtF,IAAI,OAAO,EAAE;YACX,SAAS,CAAC,0BAA0B,CAAC,IAAI,mBAAmB,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;SACzE;IACH,CAAC;IACD,mFAAmF;IACnF,uDAAuD;IACvD,EAAE,CACH,CAAC;IAEF,SAAS,CAAC;QACR,IAAM,OAAO,GAAG,OAAO,UAAU,KAAK,UAAU,CAAC,CAAC,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,OAAO,CAAC;QACtF,IAAI,OAAO,EAAE;YACX,IAAI,WAAS,GAAG,IAAI,CAAC;YACrB,IAAM,UAAQ,GAAG,IAAI,cAAc,CAAC,UAAA,OAAO;gBACzC,gEAAgE;gBAChE,IAAI,WAAS,EAAE;oBACb,eAAe,CAAC,0BAA0B,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;iBACzD;YACH,CAAC,CAAC,CAAC;YACH,UAAQ,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YAC1B,OAAO;gBACL,WAAS,GAAG,KAAK,CAAC;gBAClB,UAAQ,CAAC,UAAU,EAAE,CAAC;YACxB,CAAC,CAAC;SACH;IACH,CAAC,EAAE,CAAC,UAAU,EAAE,eAAe,CAAC,CAAC,CAAC;AACpC,CAAC;AAED,SAAS,0BAA0B,CAAC,KAA0B;IAC5D,OAAO;QACL,MAAM,EAAE,KAAK,CAAC,MAAM;QACpB,eAAe,EAAE,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,UAAU;QACnD,gBAAgB,EAAE,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,SAAS;QACnD,cAAc,EAAE,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,UAAU;QACjD,eAAe,EAAE,KAAK,CAAC,aAAa,CAAC,CAAC,CAAC,CAAC,SAAS;QACjD,KAAK,EAAE,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,UAAU;QACzC,MAAM,EAAE,KAAK,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,SAAS;KAC1C,CAAC;AACJ,CAAC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ResizeObserver, ResizeObserverEntry } from '@juggle/resize-observer';\nimport React, { useEffect, useLayoutEffect } from 'react';\nimport { useStableEventHandler } from '../use-stable-event-handler';\nimport { ContainerQueryEntry } from './interfaces';\n\ntype ElementReference = (() => Element | null) | React.RefObject<Element>;\n\n/**\n * Attaches resize-observer to the referenced element.\n *\n * Examples:\n *     // With React reference\n *     const ref = useRef(null)\n *     useResizeObserver(ref, (entry) => setState(getWidth(entry)))\n *\n *     // With ID reference\n *     const getElement = useCallback(() => document.getElementById(id), [id])\n *     useResizeObserver(getElement, (entry) => setState(getWidth(entry)))\n *\n * @param elementRef React reference or memoized getter for the target element\n * @param onObserve Function to fire when observation occurs\n */\nexport function useResizeObserver(elementRef: ElementReference, onObserve: (entry: ContainerQueryEntry) => void) {\n  const stableOnObserve = useStableEventHandler(onObserve);\n\n  // This effect provides a synchronous update required to prevent flakiness when initial state and first observed state are different.\n  // Can potentially conflict with React concurrent mode: https://17.reactjs.org/docs/concurrent-mode-intro.html.\n  // A possible solution would be to make consumers not render any content until the first (asynchronous) observation is available.\n  useLayoutEffect(\n    () => {\n      const element = typeof elementRef === 'function' ? elementRef() : elementRef?.current;\n      if (element) {\n        onObserve(convertResizeObserverEntry(new ResizeObserverEntry(element)));\n      }\n    },\n    // This effect is only needed for the first render to provide a synchronous update.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n\n  useEffect(() => {\n    const element = typeof elementRef === 'function' ? elementRef() : elementRef?.current;\n    if (element) {\n      let connected = true;\n      const observer = new ResizeObserver(entries => {\n        // Prevent observe notifications on already unmounted component.\n        if (connected) {\n          stableOnObserve(convertResizeObserverEntry(entries[0]));\n        }\n      });\n      observer.observe(element);\n      return () => {\n        connected = false;\n        observer.disconnect();\n      };\n    }\n  }, [elementRef, stableOnObserve]);\n}\n\nfunction convertResizeObserverEntry(entry: ResizeObserverEntry): ContainerQueryEntry {\n  return {\n    target: entry.target,\n    contentBoxWidth: entry.contentBoxSize[0].inlineSize,\n    contentBoxHeight: entry.contentBoxSize[0].blockSize,\n    borderBoxWidth: entry.borderBoxSize[0].inlineSize,\n    borderBoxHeight: entry.borderBoxSize[0].blockSize,\n    width: entry.contentBoxSize[0].inlineSize,\n    height: entry.contentBoxSize[0].blockSize,\n  };\n}\n"]}