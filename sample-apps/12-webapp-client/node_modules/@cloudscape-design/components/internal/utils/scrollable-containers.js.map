{"version":3,"file":"scrollable-containers.js","sourceRoot":"","sources":["../../../../src/internal/utils/scrollable-containers.ts"],"names":[],"mappings":"AASA,MAAM,CAAC,IAAM,kBAAkB,GAAG,UAAC,OAAoB;IACrD,IAAM,OAAO,GAAG,EAAE,CAAC;IACnB,IAAI,IAAI,GAAuB,OAAO,CAAC;IAEvC,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC,aAAa,CAAC,IAAI,IAAI,KAAK,QAAQ,CAAC,IAAI,EAAE;QAC5D,gBAAgB,CAAC,IAAI,CAAC,CAAC,QAAQ,KAAK,SAAS,IAAI,OAAO,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KACrE;IACD,OAAO,OAAO,CAAC;AACjB,CAAC,CAAC;AAEF,MAAM,CAAC,IAAM,2BAA2B,GAAG,UACzC,OAAoB,EACpB,oBAA4B,EAC5B,gBAAwB,EACxB,wBAAgC;IAFhC,qCAAA,EAAA,4BAA4B;IAC5B,iCAAA,EAAA,wBAAwB;IACxB,yCAAA,EAAA,gCAAgC;IAEhC,IAAM,OAAO,GAAG,gBAAgB;QAC9B,CAAC,CAAC,EAAE;QACJ,CAAC,CAAC,kBAAkB,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,UAAA,EAAE;YAC1B,IAAA,KAA+B,EAAE,CAAC,qBAAqB,EAAE,EAAvD,MAAM,YAAA,EAAE,KAAK,WAAA,EAAE,GAAG,SAAA,EAAE,IAAI,UAA+B,CAAC;YAChE,OAAO;gBACL,0DAA0D;gBAC1D,gDAAgD;gBAChD,MAAM,EAAE,wBAAwB,CAAC,CAAC,CAAC,EAAE,CAAC,YAAY,CAAC,CAAC,CAAC,MAAM;gBAC3D,KAAK,OAAA;gBACL,GAAG,KAAA;gBACH,IAAI,MAAA;aACL,CAAC;QACJ,CAAC,CAAC,CAAC;IAEP,IAAI,wBAAwB,IAAI,CAAC,gBAAgB,EAAE;QACjD,IAAM,kBAAkB,GAAG,QAAQ,CAAC,eAAe,CAAC,qBAAqB,EAAE,CAAC;QAC5E,OAAO,CAAC,IAAI,CAAC;YACX,KAAK,EAAE,IAAI,CAAC,GAAG,CAAC,kBAAkB,CAAC,KAAK,EAAE,QAAQ,CAAC,eAAe,CAAC,WAAW,CAAC;YAC/E,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,kBAAkB,CAAC,MAAM,EAAE,QAAQ,CAAC,eAAe,CAAC,YAAY,CAAC;YAClF,GAAG,EAAE,kBAAkB,CAAC,GAAG;YAC3B,IAAI,EAAE,kBAAkB,CAAC,IAAI;SAC9B,CAAC,CAAC;KACJ;SAAM;QACL,OAAO,CAAC,IAAI,CAAC;YACX,MAAM,EAAE,MAAM,CAAC,WAAW;YAC1B,KAAK,EAAE,MAAM,CAAC,UAAU;YACxB,GAAG,EAAE,CAAC;YACN,IAAI,EAAE,CAAC;SACR,CAAC,CAAC;KACJ;IAED,IAAI,oBAAoB,IAAI,CAAC,gBAAgB,EAAE;QAC7C,OAAO,CAAC,KAAK,EAAE,CAAC;KACjB;IAED,OAAO,OAAO,CAAC;AACjB,CAAC,CAAC;AAEF;;;;;GAKG;AACH,MAAM,UAAU,kBAAkB,CAAC,OAAoB;;IACrD,IAAM,MAAM,GAAG,MAAA,OAAO,CAAC,YAAY,mCAAI,QAAQ,CAAC,eAAe,CAAC;IAChE,kCAAkC;IAClC,IAAI,OAAO,CAAC,SAAS,GAAG,MAAM,CAAC,SAAS,EAAE;QACxC,MAAM,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;KACtC;IACD,qCAAqC;IACrC,IAAI,OAAO,CAAC,SAAS,GAAG,OAAO,CAAC,YAAY,GAAG,MAAM,CAAC,SAAS,GAAG,MAAM,CAAC,YAAY,EAAE;QACrF,MAAM,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,GAAG,OAAO,CAAC,YAAY,GAAG,MAAM,CAAC,YAAY,CAAC;KACnF;AACH,CAAC;AAID;;;;;;;;;GASG;AACH,MAAM,UAAU,qBAAqB,CACnC,OAAgC,EAChC,OAAwE;;IAAxE,wBAAA,EAAA,YAAmC,KAAK,EAAE,SAAS,EAAE,MAAM,EAAE,SAAS,EAAE;IAExE,MAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,cAAc,wDAAG,OAAO,CAAC,CAAC;AACrC,CAAC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport interface Dimensions {\n  height: number;\n  width: number;\n  top: number;\n  left: number;\n}\n\nexport const getOverflowParents = (element: HTMLElement): HTMLElement[] => {\n  const parents = [];\n  let node: HTMLElement | null = element;\n\n  while ((node = node.parentElement) && node !== document.body) {\n    getComputedStyle(node).overflow !== 'visible' && parents.push(node);\n  }\n  return parents;\n};\n\nexport const getOverflowParentDimensions = (\n  element: HTMLElement,\n  excludeClosestParent = false,\n  expandToViewport = false,\n  canExpandOutsideViewport = false\n): Dimensions[] => {\n  const parents = expandToViewport\n    ? []\n    : getOverflowParents(element).map(el => {\n        const { height, width, top, left } = el.getBoundingClientRect();\n        return {\n          // Treat the whole scrollable area as the available height\n          // if we're allowed to expand past the viewport.\n          height: canExpandOutsideViewport ? el.scrollHeight : height,\n          width,\n          top,\n          left,\n        };\n      });\n\n  if (canExpandOutsideViewport && !expandToViewport) {\n    const documentDimensions = document.documentElement.getBoundingClientRect();\n    parents.push({\n      width: Math.max(documentDimensions.width, document.documentElement.clientWidth),\n      height: Math.max(documentDimensions.height, document.documentElement.clientHeight),\n      top: documentDimensions.top,\n      left: documentDimensions.left,\n    });\n  } else {\n    parents.push({\n      height: window.innerHeight,\n      width: window.innerWidth,\n      top: 0,\n      left: 0,\n    });\n  }\n\n  if (excludeClosestParent && !expandToViewport) {\n    parents.shift();\n  }\n\n  return parents;\n};\n\n/**\n * If the element is out of view, scrolls the scroll parent until\n * the element is visible.\n *\n * Basically an IE11/Safari polyfill for `elem.scrollIntoView({ block: 'nearest' })`\n */\nexport function scrollUntilVisible(element: HTMLElement): void {\n  const parent = element.offsetParent ?? document.documentElement;\n  // Anchor to top of scroll parent.\n  if (element.offsetTop < parent.scrollTop) {\n    parent.scrollTop = element.offsetTop;\n  }\n  // Anchor to bottom of scroll parent.\n  if (element.offsetTop + element.clientHeight > parent.scrollTop + parent.clientHeight) {\n    parent.scrollTop = element.offsetTop + element.clientHeight - parent.clientHeight;\n  }\n}\n\ntype ScrollIntoViewOptions = Parameters<HTMLElement['scrollIntoView']>[0];\n\n/**\n * Calls `scrollIntoView` on the provided element with sensible defaults. If\n * the element does not existed or does not support the `scrollIntoView`\n * method, it will do nothing. This wrapper is created to support environments\n * where the native function is not available like JSDom (feature request:\n * https://github.com/jsdom/jsdom/issues/1422).\n *\n * @param element to be scrolled into view\n * @param options native options for `scrollIntoView`\n */\nexport function scrollElementIntoView(\n  element: HTMLElement | undefined,\n  options: ScrollIntoViewOptions = { block: 'nearest', inline: 'nearest' }\n) {\n  element?.scrollIntoView?.(options);\n}\n"]}