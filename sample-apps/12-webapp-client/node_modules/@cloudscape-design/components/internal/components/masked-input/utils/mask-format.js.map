{"version":3,"file":"mask-format.js","sourceRoot":"","sources":["../../../../../../src/internal/components/masked-input/utils/mask-format.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { padLeftZeros } from '../../../utils/strings';\nimport { insertAt } from './strings';\n\ninterface FormatSegment {\n  min: number;\n  max: number | ((value: string) => number);\n  length: number;\n  default?: number;\n}\n\ninterface FormatSegmentFull extends FormatSegment {\n  start: number;\n  max(value: string): number;\n  end: number;\n}\n\nexport interface MaskArgs {\n  separator: string;\n  inputSeparators?: Array<string>;\n  segments: Array<FormatSegment>;\n}\n\nexport interface ChangeResult {\n  value: string;\n  position: number;\n}\n\nclass MaskFormat {\n  separator: string;\n  private inputSeparators: Array<string>;\n  private segments: Array<FormatSegmentFull>;\n  private positionFormats: { [x: number]: FormatSegmentFull };\n\n  constructor({ separator, inputSeparators = [], segments }: MaskArgs) {\n    this.positionFormats = {};\n    this.segments = [];\n    this.separator = separator;\n\n    this.inputSeparators = [...inputSeparators, separator];\n    this.enrichSegmentDefinitions(segments);\n  }\n\n  tryAppendSeparator(value: string) {\n    const withSeparator = `${value}${this.separator}`;\n    return this.isValid(withSeparator) ? withSeparator : value;\n  }\n\n  isSeparator(key: string): boolean {\n    return this.inputSeparators.indexOf(key) !== -1;\n  }\n\n  isValid(value: string): boolean {\n    const inputSegments = value.split(this.separator);\n\n    if (inputSegments.length > this.segments.length) {\n      return false;\n    }\n\n    return inputSegments.every((segmentValue, i) => {\n      const segment = this.segments[i];\n\n      // disallow empty segments\n      if (segmentValue === '') {\n        // except empty last segment (e.g. trailing separator \"12:\")\n        if (i === inputSegments.length - 1) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n      // only allow numerals\n      if (!segmentValue.match(/^\\d+$/)) {\n        return false;\n      }\n      // disallow incomplete segments, except at end\n      if (segmentValue.length < segment.length && i !== inputSegments.length - 1) {\n        return false;\n      }\n      // limit numerical value\n      const intValue = parseInt(segmentValue, 10);\n\n      // Handles values padded with 0s that are lost during parsing\n      if (segmentValue.length > segment.length) {\n        return false;\n      }\n\n      if (intValue < segment.min || intValue > segment.max(value)) {\n        // allow incomplete segments in final position\n        if (i === inputSegments.length - 1 && segmentValue.length < segment.length) {\n          return true;\n        }\n        return false;\n      }\n      return true;\n    });\n  }\n\n  getValidValue(value: string): string {\n    let validValue = value;\n\n    do {\n      if (this.isValid(validValue)) {\n        return this.tryAppendSeparator(validValue);\n      }\n\n      validValue = validValue.substring(0, validValue.length - 1);\n    } while (validValue.length > 0);\n\n    return '';\n  }\n\n  autoComplete(value: string): string {\n    // aka [...completeSegments, lastSegment] = value.split(':')\n    // but that's not valid :/\n    const [lastSegmentValue, ...completeSegmentValues] = value.split(this.separator).reverse();\n    const lastSegment = this.segments[completeSegmentValues.length];\n\n    // if the last segment isn't complete, pad it with a preceding 0\n    // e.g. 10:1 -> 10:01\n    const paddedLastSegmentValue = this.padWithDefaultValue(lastSegmentValue, lastSegment);\n\n    // recombine, and pad with extra segments for the full format\n    const partial = [...completeSegmentValues.reverse(), paddedLastSegmentValue];\n    while (partial.length < this.segments.length) {\n      const nextSegment = this.segments[partial.length];\n      const segmentValue = this.padWithDefaultValue('', nextSegment);\n      partial.push(segmentValue);\n    }\n    value = partial.join(this.separator);\n    value = this.correctMinMaxValues(value);\n    return value;\n  }\n\n  getSegmentValueWithAddition(position: number, value: string, enteredDigit: string) {\n    const segment = this.positionFormats[position];\n    const segmentValue = value.substr(segment.start, segment.length);\n    const segmentPosition = position - segment.start;\n    const newValue = insertAt(segmentValue, enteredDigit, segmentPosition, segmentPosition + 1);\n    return parseInt(newValue, 10);\n  }\n\n  replaceDigitsWithZeroes(value: string, cursorStart: number, cursorEnd: number): ChangeResult {\n    const position = this.isCursorAtSeparator(cursorStart) ? cursorStart + 1 : cursorStart;\n\n    // move selection forwards if it starts with a separator\n    if (this.isCursorAtSeparator(cursorStart)) {\n      cursorStart++;\n    }\n\n    // first, insert zeros in a partial segment at beginning of selection\n    if (!this.isSegmentStart(cursorStart)) {\n      const segment = this.positionFormats[cursorStart];\n      value = insertAt(value, padLeftZeros('', segment.end - cursorStart), cursorStart, segment.end);\n      cursorStart = segment.end + 1;\n    }\n\n    // then loop through remaining segments, filling with zeros\n    let currentSegment: FormatSegmentFull;\n    while (cursorStart < cursorEnd && (currentSegment = this.positionFormats[cursorStart + 1])) {\n      const insertionEnd = Math.min(cursorEnd, currentSegment.end);\n      value = insertAt(\n        value,\n        padLeftZeros('', insertionEnd - currentSegment.start),\n        currentSegment.start,\n        insertionEnd\n      );\n      cursorStart = insertionEnd + 1;\n    }\n\n    value = this.correctMinMaxValues(value);\n\n    return {\n      value,\n      position,\n    };\n  }\n\n  handleSeparatorInput(value: string, position: number): ChangeResult | void {\n    if (position === value.length && !this.isSegmentStart(position)) {\n      const segment = this.positionFormats[position];\n      let segmentValue = value.substr(segment.start, segment.length);\n      segmentValue = this.padWithDefaultValue(segmentValue, segment);\n      value = insertAt(value, segmentValue, segment.start, segment.end);\n      value = this.correctMinMaxValues(value);\n      return {\n        value,\n        position: value.length,\n      };\n    }\n  }\n\n  isCursorAtSeparator(position: number) {\n    return 0 < position && position < this.getMaxLength() && this.positionFormats[position] === undefined;\n  }\n\n  isSegmentStart(position: number) {\n    return position === 0 || this.isCursorAtSeparator(position - 1);\n  }\n\n  getSegmentMaxValue(value: string, position: number): number {\n    return this.positionFormats[position].max(value);\n  }\n\n  getSegmentMinValue(value: string, position: number): number {\n    return this.positionFormats[position].min;\n  }\n\n  getMaxLength() {\n    const last = this.segments[this.segments.length - 1];\n    return last.start + last.length;\n  }\n\n  deleteSeparator(value: string, position: number): ChangeResult {\n    value = insertAt(value, '0', position - 2, position - 1);\n\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 2,\n    };\n  }\n\n  deleteDigit(value: string, position: number): ChangeResult {\n    value = insertAt(value, '0', position - 1, position);\n\n    // 23:59|: => backspace => 23:5|\n    const length = value.length;\n    if (value.slice(length - 2) === '0:') {\n      value = value.slice(0, length - 2);\n    }\n\n    return {\n      value: this.correctMinMaxValues(value),\n      position: position - 1,\n    };\n  }\n\n  correctMinMaxValues(value: string): string {\n    let segment = this.positionFormats[0];\n    while (segment && value.length >= segment.end) {\n      const segmentValue = parseInt(value.substr(segment.start, segment.length), 10);\n      const segmentMax = segment.max(value);\n      if (segmentValue < segment.min) {\n        let toInsert = segment.min.toFixed();\n        toInsert = padLeftZeros(toInsert, segment.length);\n        value = insertAt(value, toInsert, segment.start, segment.end);\n      }\n      if (segmentValue > segmentMax) {\n        value = insertAt(value, segmentMax.toFixed(), segment.start, segment.end);\n      }\n      segment = this.positionFormats[segment.end + 1];\n    }\n    return value.substr(0, this.segments[this.segments.length - 1].end);\n  }\n\n  formatPastedText(text: string, value: string, cursorStart: number, cursorEnd: number): string {\n    const keyArr = text.trim().split('');\n\n    let position = cursorStart;\n\n    let formattedValue = value;\n    // if a selection range captures the end of the current value\n    // we replace it with the value in buffer even if the value in buffer is shorter\n    if (cursorEnd > cursorStart && cursorEnd === value.length) {\n      formattedValue = value.slice(0, cursorStart);\n    }\n\n    for (const key of keyArr) {\n      if (position >= this.getMaxLength()) {\n        break;\n      }\n\n      const result = this.processKey(formattedValue, key, position);\n      formattedValue = result.value;\n      position = result.position;\n    }\n\n    return this.tryAppendSeparator(formattedValue);\n  }\n\n  processKey(initialValue: string, key: string, initialPosition: number) {\n    let value = initialValue;\n    let position = initialPosition;\n\n    if (this.isSeparator(key)) {\n      const result = this.handleSeparatorInput(value, position);\n      if (result) {\n        value = result.value;\n        position = result.position;\n      }\n    } else {\n      const isCursorAtEnd = position === value.length;\n      const segmentValue = this.getSegmentValueWithAddition(position, value, key);\n      const segmentMaxValue = this.getSegmentMaxValue(value, position);\n      const segmentMinValue = this.getSegmentMinValue(value, position);\n      const firstDigitGreater = parseInt(key, 10) > parseInt(segmentMaxValue.toFixed()[0], 10);\n      const isValidPosition = isCursorAtEnd || segmentValue.toFixed().length === 1;\n      const exceedsMaxAtSegmentStart = this.isSegmentStart(position) && isValidPosition && firstDigitGreater;\n\n      if (exceedsMaxAtSegmentStart) {\n        // 22:| => Enter '9' => 22:09|\n        // |1 => Enter '9' => 09|\n        value = insertAt(value, `0${key}`, position, position + 2);\n        position += 2;\n      } else if (segmentValue > segmentMaxValue && this.isSegmentStart(position)) {\n        // 22:|22 => Enter '9' => 22:59|\n        value = insertAt(value, segmentMaxValue.toFixed(), position, position + segmentMaxValue.toFixed().length);\n        position += segmentMaxValue.toFixed().length;\n      } else if (segmentValue > segmentMaxValue) {\n        // 2|2:22 => Enter '9' => 23:|22\n        value = insertAt(value, segmentMaxValue.toFixed(), position - 1, position + 1);\n        position += 1;\n      } else if (segmentValue < segmentMinValue && !this.isSegmentStart(position)) {\n        // 0| => enter '0' => 01:\n        value = insertAt(value, segmentMinValue.toFixed(), position, position + 1);\n        position += 1;\n      } else {\n        // 22:| => Enter '5' => 23:5|\n        value = insertAt(value, key, position, position + 1);\n        position += 1;\n      }\n    }\n\n    value = this.tryAppendSeparator(value);\n\n    // Move cursor in front of separator if behind after overwriting a character\n    if (this.isCursorAtSeparator(position)) {\n      position++;\n    }\n\n    return { value, position };\n  }\n\n  private padWithDefaultValue(segmentValue: string, segment: FormatSegmentFull) {\n    let defaultValue = (segment.default || segment.min).toFixed();\n    defaultValue = padLeftZeros(defaultValue, segment.length);\n    return insertAt(defaultValue, segmentValue, segment.length - segmentValue.length, segment.length);\n  }\n\n  private enrichSegmentDefinitions(segments: FormatSegment[]) {\n    this.positionFormats = {};\n    this.segments = [];\n    let position = 0;\n    for (const segment of segments) {\n      const max = segment.max;\n      const fullSegment: FormatSegmentFull = {\n        ...segment,\n        max: typeof max === 'number' ? () => max : max,\n        start: position,\n        end: position + segment.length,\n      };\n      this.segments.push(fullSegment);\n      // insert this format segment for every char in the max value\n      for (let j = 0; j < fullSegment.length; j++) {\n        this.positionFormats[position++] = fullSegment;\n      }\n      // skip a position for separator\n      position++;\n    }\n  }\n}\n\nexport default MaskFormat;\n"]}