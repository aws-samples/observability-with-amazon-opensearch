import { __assign } from "tslib";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { useCallback, useMemo, useState } from 'react';
import { KeyCode } from '../../internal/keycode';
import { findNavigableSeries, nextValidDomainIndex } from '../utils';
export function useNavigation(_a) {
    var series = _a.series, visibleSeries = _a.visibleSeries, scaledSeries = _a.scaledSeries, barGroups = _a.barGroups, xScale = _a.xScale, yScale = _a.yScale, highlightedPoint = _a.highlightedPoint, highlightedGroupIndex = _a.highlightedGroupIndex, highlightedSeries = _a.highlightedSeries, legendSeries = _a.legendSeries, isHandlersDisabled = _a.isHandlersDisabled, pinPopover = _a.pinPopover, highlightSeries = _a.highlightSeries, highlightGroup = _a.highlightGroup, highlightPoint = _a.highlightPoint;
    var _b = useState(null), targetX = _b[0], setTargetX = _b[1];
    // There are two different types of navigation:
    // 1) Group navigation for any chart that contains a bar series
    // 2) Line navigation for any chart that only contains lines and thresholds
    var isGroupNavigation = visibleSeries.some(function (_a) {
        var series = _a.series;
        return series.type === 'bar';
    });
    // Make a list of series that can be navigated between. Bar series are treated as one.
    var navigableSeries = useMemo(function () { return findNavigableSeries(visibleSeries); }, [visibleSeries]).navigableSeries;
    var onBarGroupFocus = function () {
        var groupIndex = highlightedGroupIndex !== null && highlightedGroupIndex !== void 0 ? highlightedGroupIndex : 0;
        setTargetX(xScale.domain[groupIndex]);
        highlightGroup(groupIndex);
    };
    var onLineGroupFocus = function () {
        var _a, _b, _c;
        if (!highlightedSeries || !highlightedPoint) {
            var targetSeries = (_c = (_a = highlightedSeries !== null && highlightedSeries !== void 0 ? highlightedSeries : legendSeries) !== null && _a !== void 0 ? _a : (_b = series[0]) === null || _b === void 0 ? void 0 : _b.series) !== null && _c !== void 0 ? _c : null;
            highlightSeries(targetSeries);
            for (var _i = 0, scaledSeries_1 = scaledSeries; _i < scaledSeries_1.length; _i++) {
                var scaledS = scaledSeries_1[_i];
                if (scaledS.series === targetSeries) {
                    highlightPoint(scaledS);
                    return;
                }
            }
        }
    };
    var onFocus = function () {
        if (isGroupNavigation) {
            onBarGroupFocus();
        }
        else {
            onLineGroupFocus();
        }
    };
    var moveBetweenSeries = useCallback(function (direction) {
        var _a, _b, _c;
        if (isGroupNavigation) {
            return;
        }
        var xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;
        var MAX_SERIES_INDEX = navigableSeries.length - 1;
        // Find the index of the currently highlighted series (if any)
        var previousSeriesIndex = -1;
        if (highlightedSeries) {
            previousSeriesIndex = navigableSeries.indexOf(highlightedSeries);
        }
        // Move forwards or backwards to the new series
        var nextSeriesIndex = 0;
        if (previousSeriesIndex !== -1) {
            nextSeriesIndex = previousSeriesIndex + direction;
            if (nextSeriesIndex > MAX_SERIES_INDEX) {
                nextSeriesIndex = 0;
            }
            else if (nextSeriesIndex < 0) {
                nextSeriesIndex = MAX_SERIES_INDEX;
            }
        }
        var nextSeries = navigableSeries[nextSeriesIndex];
        var nextInternalSeries = series.filter(function (_a) {
            var series = _a.series;
            return series === nextSeries;
        })[0];
        // 2. Find point in the next series
        var targetXPoint = ((_a = xScale.d3Scale(targetX)) !== null && _a !== void 0 ? _a : NaN) + xOffset;
        if (!isFinite(targetXPoint)) {
            targetXPoint = 0;
        }
        if (nextSeries.type === 'line') {
            var nextSeriesData = nextSeries.data;
            var lookingForScaled_1 = targetXPoint; // scaled X in previous series
            var nextPoint = nextSeriesData
                // scale all points in series
                .map(function (d) { return ({
                x: (xScale.d3Scale(d.x) || 0) + xOffset,
                y: yScale.d3Scale(d.y) || 0,
                datum: d
            }); })
                // find the closest point to previous X
                .reduce(function (prev, curr) { return (Math.abs(curr.x - lookingForScaled_1) < Math.abs(prev.x - lookingForScaled_1) ? curr : prev); }, { x: -Infinity, y: -Infinity });
            highlightSeries(nextSeries);
            highlightPoint(__assign(__assign({}, nextPoint), { color: nextInternalSeries.color, series: nextSeries }));
        }
        else if (nextSeries.type === 'threshold') {
            var scaledTargetIndex = scaledSeries.map(function (it) { var _a; return ((_a = it.datum) === null || _a === void 0 ? void 0 : _a.x) || null; }).indexOf(targetX);
            highlightSeries(nextSeries);
            highlightPoint({
                x: targetXPoint,
                y: (_b = yScale.d3Scale(nextSeries.y)) !== null && _b !== void 0 ? _b : NaN,
                color: nextInternalSeries.color,
                series: nextSeries,
                datum: (_c = scaledSeries[scaledTargetIndex]) === null || _c === void 0 ? void 0 : _c.datum
            });
        }
    }, [
        isGroupNavigation,
        xScale,
        navigableSeries,
        highlightedSeries,
        scaledSeries,
        series,
        targetX,
        highlightSeries,
        highlightPoint,
        yScale,
    ]);
    var moveWithinSeries = useCallback(function (direction) {
        var _a;
        var series = highlightedSeries || visibleSeries[0].series;
        var previousPoint = highlightedPoint || scaledSeries[0];
        if (series.type === 'line') {
            // find previous point in series
            var indexOfPreviousPoint = (previousPoint === null || previousPoint === void 0 ? void 0 : previousPoint.datum)
                ? series.data.indexOf(previousPoint.datum)
                : 0;
            var nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, series.data.length - 1]);
            var nextPoint_1 = series.data[nextPointIndex];
            // find scaled next point
            var nextPointScaled = scaledSeries.filter(function (s) { return s.datum === nextPoint_1; })[0] || null;
            setTargetX(nextPoint_1.x);
            highlightSeries(series);
            highlightPoint(nextPointScaled);
        }
        else if (series.type === 'threshold') {
            var scaledThresholdSeries = scaledSeries.filter(function (it) { return it.series === series; })[0];
            var scaledDataSeries = scaledSeries.filter(function (it) { return it.datum; });
            var indexOfPreviousPoint = scaledDataSeries.map(function (it) { return it.x; }).indexOf(previousPoint.x);
            var nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, scaledDataSeries.length - 1]);
            setTargetX(((_a = scaledDataSeries[nextPointIndex].datum) === null || _a === void 0 ? void 0 : _a.x) || null);
            highlightSeries(series);
            highlightPoint(__assign(__assign({}, scaledThresholdSeries), { datum: scaledDataSeries[nextPointIndex].datum, x: scaledDataSeries[nextPointIndex].x }));
        }
        else if (series.type === 'bar') {
            var xDomain = xScale.domain;
            var MAX_GROUP_INDEX = xDomain.length - 1;
            var nextGroupIndex = 0;
            if (highlightedGroupIndex !== null) {
                // find next group
                nextGroupIndex = highlightedGroupIndex + direction;
                if (nextGroupIndex > MAX_GROUP_INDEX) {
                    nextGroupIndex = 0;
                }
                else if (nextGroupIndex < 0) {
                    nextGroupIndex = MAX_GROUP_INDEX;
                }
            }
            var nextDomainIndex = nextValidDomainIndex(nextGroupIndex, barGroups, direction);
            setTargetX(xDomain[nextDomainIndex]);
            highlightGroup(nextDomainIndex);
        }
    }, [
        highlightedSeries,
        visibleSeries,
        highlightedPoint,
        scaledSeries,
        highlightSeries,
        highlightPoint,
        xScale.domain,
        highlightedGroupIndex,
        barGroups,
        highlightGroup,
    ]);
    var onKeyDown = useCallback(function (event) {
        var keyCode = event.keyCode;
        if (keyCode !== KeyCode.up &&
            keyCode !== KeyCode.right &&
            keyCode !== KeyCode.down &&
            keyCode !== KeyCode.left &&
            keyCode !== KeyCode.space &&
            keyCode !== KeyCode.enter) {
            return;
        }
        event.preventDefault();
        if (isHandlersDisabled) {
            return;
        }
        if (keyCode === KeyCode.down || keyCode === KeyCode.up) {
            moveBetweenSeries(keyCode === KeyCode.down ? 1 : -1);
        }
        else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {
            moveWithinSeries(keyCode === KeyCode.right ? 1 : -1);
        }
        else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {
            pinPopover();
        }
    }, [moveWithinSeries, moveBetweenSeries, isHandlersDisabled, pinPopover]);
    return { isGroupNavigation: isGroupNavigation, onFocus: onFocus, onKeyDown: onKeyDown };
}
// Returns given index if it is in range or the opposite range boundary otherwise.
function circleIndex(index, _a) {
    var from = _a[0], to = _a[1];
    if (index < from) {
        return to;
    }
    if (index > to) {
        return from;
    }
    return index;
}
//# sourceMappingURL=use-navigation.js.map