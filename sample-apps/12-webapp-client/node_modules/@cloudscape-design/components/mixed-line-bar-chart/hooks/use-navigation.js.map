{"version":3,"file":"use-navigation.js","sourceRoot":"","sources":["../../../../src/mixed-line-bar-chart/hooks/use-navigation.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useMemo, useState } from 'react';\nimport { KeyCode } from '../../internal/keycode';\nimport { ChartContainerProps } from '../chart-container';\nimport { ChartDataTypes, MixedLineBarChartProps } from '../interfaces';\nimport { ChartScale, NumericChartScale } from '../../internal/components/cartesian-chart/scales';\nimport { findNavigableSeries, nextValidDomainIndex } from '../utils';\nimport { ScaledPoint } from '../make-scaled-series';\nimport { ScaledBarGroup } from '../make-scaled-bar-groups';\n\nexport type UseNavigationProps<T extends ChartDataTypes> = Pick<\n  ChartContainerProps<T>,\n  'highlightedSeries' | 'series' | 'visibleSeries'\n> & {\n  xScale: ChartScale;\n  yScale: NumericChartScale;\n  barGroups: ScaledBarGroup<T>[];\n  scaledSeries: ReadonlyArray<ScaledPoint<T>>;\n\n  highlightedPoint: ScaledPoint<T> | null;\n  highlightedGroupIndex: number | null;\n  legendSeries: null | MixedLineBarChartProps.ChartSeries<T>;\n  isHandlersDisabled: boolean;\n\n  pinPopover(pinned?: boolean): void;\n  highlightSeries(series: MixedLineBarChartProps.ChartSeries<T> | null): void;\n  highlightGroup(groupIndex: number): void;\n  highlightPoint(point: ScaledPoint<T> | null): void;\n  clearHighlightedSeries(): void;\n};\n\nexport function useNavigation<T extends ChartDataTypes>({\n  series,\n  visibleSeries,\n  scaledSeries,\n  barGroups,\n  xScale,\n  yScale,\n  highlightedPoint,\n  highlightedGroupIndex,\n  highlightedSeries,\n  legendSeries,\n  isHandlersDisabled,\n  pinPopover,\n  highlightSeries,\n  highlightGroup,\n  highlightPoint,\n}: UseNavigationProps<T>) {\n  const [targetX, setTargetX] = useState<T | null>(null);\n\n  // There are two different types of navigation:\n  // 1) Group navigation for any chart that contains a bar series\n  // 2) Line navigation for any chart that only contains lines and thresholds\n  const isGroupNavigation = visibleSeries.some(({ series }) => series.type === 'bar');\n\n  // Make a list of series that can be navigated between. Bar series are treated as one.\n  const { navigableSeries } = useMemo(() => findNavigableSeries(visibleSeries), [visibleSeries]);\n\n  const onBarGroupFocus = () => {\n    const groupIndex = highlightedGroupIndex ?? 0;\n    setTargetX((xScale.domain as T[])[groupIndex]);\n    highlightGroup(groupIndex);\n  };\n\n  const onLineGroupFocus = () => {\n    if (!highlightedSeries || !highlightedPoint) {\n      const targetSeries = highlightedSeries ?? legendSeries ?? series[0]?.series ?? null;\n      highlightSeries(targetSeries);\n      for (const scaledS of scaledSeries) {\n        if (scaledS.series === targetSeries) {\n          highlightPoint(scaledS);\n          return;\n        }\n      }\n    }\n  };\n\n  const onFocus = () => {\n    if (isGroupNavigation) {\n      onBarGroupFocus();\n    } else {\n      onLineGroupFocus();\n    }\n  };\n\n  const moveBetweenSeries = useCallback(\n    (direction: number) => {\n      if (isGroupNavigation) {\n        return;\n      }\n\n      const xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;\n      const MAX_SERIES_INDEX = navigableSeries.length - 1;\n\n      // Find the index of the currently highlighted series (if any)\n      let previousSeriesIndex = -1;\n      if (highlightedSeries) {\n        previousSeriesIndex = navigableSeries.indexOf(highlightedSeries);\n      }\n\n      // Move forwards or backwards to the new series\n      let nextSeriesIndex = 0;\n      if (previousSeriesIndex !== -1) {\n        nextSeriesIndex = previousSeriesIndex + direction;\n        if (nextSeriesIndex > MAX_SERIES_INDEX) {\n          nextSeriesIndex = 0;\n        } else if (nextSeriesIndex < 0) {\n          nextSeriesIndex = MAX_SERIES_INDEX;\n        }\n      }\n\n      const nextSeries = navigableSeries[nextSeriesIndex];\n      const nextInternalSeries = series.filter(({ series }) => series === nextSeries)[0];\n\n      // 2. Find point in the next series\n      let targetXPoint = (xScale.d3Scale(targetX as any) ?? NaN) + xOffset;\n      if (!isFinite(targetXPoint)) {\n        targetXPoint = 0;\n      }\n\n      if (nextSeries.type === 'line') {\n        const nextSeriesData = nextSeries.data as ReadonlyArray<MixedLineBarChartProps.Datum<T>>;\n        const lookingForScaled = targetXPoint; // scaled X in previous series\n\n        const nextPoint = nextSeriesData\n          // scale all points in series\n          .map(d => ({\n            x: (xScale.d3Scale(d.x as any) || 0) + xOffset,\n            y: yScale.d3Scale(d.y) || 0,\n            datum: d,\n          }))\n          // find the closest point to previous X\n          .reduce(\n            (prev, curr) => (Math.abs(curr.x - lookingForScaled) < Math.abs(prev.x - lookingForScaled) ? curr : prev),\n            { x: -Infinity, y: -Infinity }\n          );\n\n        highlightSeries(nextSeries);\n        highlightPoint({ ...nextPoint, color: nextInternalSeries.color, series: nextSeries });\n      } else if (nextSeries.type === 'threshold') {\n        const scaledTargetIndex = scaledSeries.map(it => it.datum?.x || null).indexOf(targetX);\n        highlightSeries(nextSeries);\n        highlightPoint({\n          x: targetXPoint,\n          y: yScale.d3Scale(nextSeries.y) ?? NaN,\n          color: nextInternalSeries.color,\n          series: nextSeries,\n          datum: scaledSeries[scaledTargetIndex]?.datum,\n        });\n      }\n    },\n    [\n      isGroupNavigation,\n      xScale,\n      navigableSeries,\n      highlightedSeries,\n      scaledSeries,\n      series,\n      targetX,\n      highlightSeries,\n      highlightPoint,\n      yScale,\n    ]\n  );\n\n  const moveWithinSeries = useCallback(\n    (direction: number) => {\n      const series = highlightedSeries || visibleSeries[0].series;\n      const previousPoint = highlightedPoint || scaledSeries[0];\n\n      if (series.type === 'line') {\n        // find previous point in series\n        const indexOfPreviousPoint = previousPoint?.datum\n          ? (series.data as ReadonlyArray<MixedLineBarChartProps.Datum<T>>).indexOf(previousPoint.datum)\n          : 0;\n        const nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, series.data.length - 1]);\n        const nextPoint = series.data[nextPointIndex];\n\n        // find scaled next point\n        const nextPointScaled = scaledSeries.filter(s => s.datum === nextPoint)[0] || null;\n\n        setTargetX(nextPoint.x as T);\n        highlightSeries(series);\n        highlightPoint(nextPointScaled);\n      } else if (series.type === 'threshold') {\n        const [scaledThresholdSeries] = scaledSeries.filter(it => it.series === series);\n        const scaledDataSeries = scaledSeries.filter(it => it.datum);\n        const indexOfPreviousPoint = scaledDataSeries.map(it => it.x).indexOf(previousPoint.x);\n        const nextPointIndex = circleIndex(indexOfPreviousPoint + direction, [0, scaledDataSeries.length - 1]);\n        setTargetX(scaledDataSeries[nextPointIndex].datum?.x || null);\n        highlightSeries(series);\n        highlightPoint({\n          ...scaledThresholdSeries,\n          datum: scaledDataSeries[nextPointIndex].datum,\n          x: scaledDataSeries[nextPointIndex].x,\n        });\n      } else if (series.type === 'bar') {\n        const xDomain = xScale.domain as T[];\n        const MAX_GROUP_INDEX = xDomain.length - 1;\n\n        let nextGroupIndex = 0;\n        if (highlightedGroupIndex !== null) {\n          // find next group\n          nextGroupIndex = highlightedGroupIndex + direction;\n          if (nextGroupIndex > MAX_GROUP_INDEX) {\n            nextGroupIndex = 0;\n          } else if (nextGroupIndex < 0) {\n            nextGroupIndex = MAX_GROUP_INDEX;\n          }\n        }\n\n        const nextDomainIndex = nextValidDomainIndex(nextGroupIndex, barGroups, direction);\n        setTargetX(xDomain[nextDomainIndex]);\n        highlightGroup(nextDomainIndex);\n      }\n    },\n    [\n      highlightedSeries,\n      visibleSeries,\n      highlightedPoint,\n      scaledSeries,\n      highlightSeries,\n      highlightPoint,\n      xScale.domain,\n      highlightedGroupIndex,\n      barGroups,\n      highlightGroup,\n    ]\n  );\n\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const keyCode = event.keyCode;\n      if (\n        keyCode !== KeyCode.up &&\n        keyCode !== KeyCode.right &&\n        keyCode !== KeyCode.down &&\n        keyCode !== KeyCode.left &&\n        keyCode !== KeyCode.space &&\n        keyCode !== KeyCode.enter\n      ) {\n        return;\n      }\n\n      event.preventDefault();\n\n      if (isHandlersDisabled) {\n        return;\n      }\n\n      if (keyCode === KeyCode.down || keyCode === KeyCode.up) {\n        moveBetweenSeries(keyCode === KeyCode.down ? 1 : -1);\n      } else if (keyCode === KeyCode.left || keyCode === KeyCode.right) {\n        moveWithinSeries(keyCode === KeyCode.right ? 1 : -1);\n      } else if (keyCode === KeyCode.enter || keyCode === KeyCode.space) {\n        pinPopover();\n      }\n    },\n    [moveWithinSeries, moveBetweenSeries, isHandlersDisabled, pinPopover]\n  );\n\n  return { isGroupNavigation, onFocus, onKeyDown };\n}\n\n// Returns given index if it is in range or the opposite range boundary otherwise.\nfunction circleIndex(index: number, [from, to]: [number, number]): number {\n  if (index < from) {\n    return to;\n  }\n  if (index > to) {\n    return from;\n  }\n  return index;\n}\n"]}