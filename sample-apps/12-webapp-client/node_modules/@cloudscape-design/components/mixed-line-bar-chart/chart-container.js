import { __rest } from "tslib";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react';
import { nodeContains } from '../internal/utils/dom';
import { useVisualRefresh } from '../internal/hooks/use-visual-mode';
import { getXTickCount, getYTickCount, createXTicks, createYTicks } from '../internal/components/cartesian-chart/ticks';
import ChartPlot from '../internal/components/chart-plot';
import AxisLabel from '../internal/components/cartesian-chart/axis-label';
import LabelsMeasure from '../internal/components/cartesian-chart/labels-measure';
import LeftLabels from '../internal/components/cartesian-chart/left-labels';
import BottomLabels from '../internal/components/cartesian-chart/bottom-labels';
import VerticalGridLines from '../internal/components/cartesian-chart/vertical-grid-lines';
import EmphasizedBaseline from '../internal/components/cartesian-chart/emphasized-baseline';
import HighlightedPoint from '../internal/components/cartesian-chart/highlighted-point';
import VerticalMarker from '../internal/components/cartesian-chart/vertical-marker';
import { ChartScale, NumericChartScale } from '../internal/components/cartesian-chart/scales';
import ChartPopover from './chart-popover';
import { computeDomainX, computeDomainY } from './utils';
import makeScaledSeries from './make-scaled-series';
import makeScaledBarGroups from './make-scaled-bar-groups';
import formatHighlighted from './format-highlighted';
import DataSeries from './data-series';
import BarGroups from './bar-groups';
import { useMouseHover } from './hooks/use-mouse-hover';
import { useNavigation } from './hooks/use-navigation';
import { usePopover } from './hooks/use-popover';
import styles from './styles.css.js';
import useContainerWidth from '../internal/utils/use-container-width';
import { useMergeRefs } from '../internal/hooks/use-merge-refs';
var LEFT_LABELS_MARGIN = 16;
var BOTTOM_LABELS_OFFSET = 12;
export default function ChartContainer(_a) {
    var _b;
    var plotHeight = _a.height, series = _a.series, visibleSeries = _a.visibleSeries, highlightedSeries = _a.highlightedSeries, onHighlightChange = _a.onHighlightChange, highlightedPoint = _a.highlightedPoint, setHighlightedPoint = _a.setHighlightedPoint, highlightedGroupIndex = _a.highlightedGroupIndex, setHighlightedGroupIndex = _a.setHighlightedGroupIndex, legendSeries = _a.legendSeries, _c = _a.detailPopoverSize, detailPopoverSize = _c === void 0 ? 'medium' : _c, _d = _a.stackedBars, stackedBars = _d === void 0 ? false : _d, _e = _a.horizontalBars, horizontalBars = _e === void 0 ? false : _e, xScaleType = _a.xScaleType, yScaleType = _a.yScaleType, xTickFormatter = _a.xTickFormatter, yTickFormatter = _a.yTickFormatter, emphasizeBaselineAxis = _a.emphasizeBaselineAxis, xTitle = _a.xTitle, yTitle = _a.yTitle, ariaLabel = _a.ariaLabel, ariaLabelledby = _a.ariaLabelledby, ariaDescription = _a.ariaDescription, _f = _a.i18nStrings, i18nStrings = _f === void 0 ? {} : _f, plotContainerRef = _a.plotContainerRef, props = __rest(_a, ["height", "series", "visibleSeries", "highlightedSeries", "onHighlightChange", "highlightedPoint", "setHighlightedPoint", "highlightedGroupIndex", "setHighlightedGroupIndex", "legendSeries", "detailPopoverSize", "stackedBars", "horizontalBars", "xScaleType", "yScaleType", "xTickFormatter", "yTickFormatter", "emphasizeBaselineAxis", "xTitle", "yTitle", "ariaLabel", "ariaLabelledby", "ariaDescription", "i18nStrings", "plotContainerRef"]);
    var plotRef = useRef(null);
    var verticalMarkerRef = useRef(null);
    var _g = useState(0), leftLabelsWidth = _g[0], setLeftLabelsWidth = _g[1];
    var _h = useState(0), bottomLabelsHeight = _h[0], setBottomLabelsHeight = _h[1];
    var _j = useContainerWidth(500), containerWidth = _j[0], containerMeasureRef = _j[1];
    var plotWidth = containerWidth ? containerWidth - leftLabelsWidth - LEFT_LABELS_MARGIN : 500;
    var containerRefObject = useRef(null);
    var containerRef = useMergeRefs(containerMeasureRef, containerRefObject);
    var isRefresh = useVisualRefresh(containerRefObject);
    var linesOnly = series.every(function (_a) {
        var series = _a.series;
        return series.type === 'line' || series.type === 'threshold';
    });
    var xDomain = (props.xDomain || computeDomainX(series, xScaleType));
    var yDomain = (props.yDomain || computeDomainY(series, yScaleType, stackedBars));
    var xTickCount = getXTickCount(plotWidth);
    var yTickCount = getYTickCount(plotHeight);
    var rangeBottomTop = [0, plotHeight];
    var rangeTopBottom = [plotHeight, 0];
    var rangeLeftRight = [0, plotWidth];
    var xScale = new ChartScale(xScaleType, xDomain, horizontalBars ? rangeBottomTop : rangeLeftRight, linesOnly);
    var yScale = new NumericChartScale(yScaleType, yDomain, horizontalBars ? rangeLeftRight : rangeTopBottom, props.yDomain ? null : yTickCount);
    var xTicks = createXTicks(xScale, xTickCount);
    var yTicks = createYTicks(yScale, yTickCount);
    /**
     * Interactions
     */
    var highlightedPointRef = useRef(null);
    var highlightedGroupRef = useRef(null);
    var _k = useState(false), isPlotFocused = _k[0], setPlotFocused = _k[1];
    // Some chart components are rendered against "x" or "y" axes,
    // When "horizontalBars" is enabled, the axes are inverted.
    var x = !horizontalBars ? 'x' : 'y';
    var y = !horizontalBars ? 'y' : 'x';
    var xy = {
        ticks: { x: xTicks, y: yTicks },
        scale: { x: xScale, y: yScale },
        tickFormatter: { x: xTickFormatter, y: yTickFormatter },
        title: { x: xTitle, y: yTitle },
        ariaRoleDescription: { x: i18nStrings.xAxisAriaRoleDescription, y: i18nStrings.yAxisAriaRoleDescription }
    };
    var scaledSeries = makeScaledSeries(visibleSeries, xScale, yScale);
    var barGroups = makeScaledBarGroups(visibleSeries, xScale, plotWidth, plotHeight, y);
    var _l = usePopover(), isPopoverOpen = _l.isPopoverOpen, isPopoverPinned = _l.isPopoverPinned, showPopover = _l.showPopover, pinPopover = _l.pinPopover, dismissPopover = _l.dismissPopover;
    // Allows to add a delay between popover is dismissed and handlers are enabled to prevent immediate popover reopening.
    var _m = useState(!isPopoverPinned), isHandlersDisabled = _m[0], setHandlersDisabled = _m[1];
    useEffect(function () {
        if (isPopoverPinned) {
            setHandlersDisabled(true);
        }
        else {
            var timeoutId_1 = setTimeout(function () { return setHandlersDisabled(false); }, 25);
            return function () { return clearTimeout(timeoutId_1); };
        }
    }, [isPopoverPinned]);
    // Highlighted point and highlighted series must be in sync.
    // TODO: refactor the code so that it is not possible to make series and point highlight out of sync.
    var highlightPoint = useCallback(function (point) {
        setHighlightedGroupIndex(null);
        setHighlightedPoint(point);
    }, [setHighlightedPoint, setHighlightedGroupIndex]);
    var highlightSeries = useCallback(function (series) {
        if (series !== highlightedSeries) {
            onHighlightChange(series);
        }
    }, [highlightedSeries, onHighlightChange]);
    var highlightGroup = useCallback(function (groupIndex) {
        highlightSeries(null);
        setHighlightedPoint(null);
        setHighlightedGroupIndex(groupIndex);
    }, [highlightSeries, setHighlightedPoint, setHighlightedGroupIndex]);
    var clearHighlightedSeries = useCallback(function () {
        highlightSeries(null);
        setHighlightedGroupIndex(null);
        setHighlightedPoint(null);
        dismissPopover();
    }, [dismissPopover, highlightSeries, setHighlightedGroupIndex, setHighlightedPoint]);
    var _o = useNavigation({
        series: series,
        visibleSeries: visibleSeries,
        scaledSeries: scaledSeries,
        barGroups: barGroups,
        xScale: xScale,
        yScale: yScale,
        highlightedPoint: highlightedPoint,
        highlightedGroupIndex: highlightedGroupIndex,
        highlightedSeries: highlightedSeries,
        legendSeries: legendSeries,
        isHandlersDisabled: isHandlersDisabled,
        pinPopover: pinPopover,
        highlightSeries: highlightSeries,
        highlightGroup: highlightGroup,
        highlightPoint: highlightPoint,
        clearHighlightedSeries: clearHighlightedSeries
    }), isGroupNavigation = _o.isGroupNavigation, handlers = __rest(_o, ["isGroupNavigation"]);
    var _p = useMouseHover({
        scaledSeries: scaledSeries,
        barGroups: barGroups,
        plotRef: plotRef,
        highlightSeries: highlightSeries,
        highlightPoint: highlightPoint,
        highlightGroup: highlightGroup,
        clearHighlightedSeries: clearHighlightedSeries,
        isGroupNavigation: isGroupNavigation,
        isHandlersDisabled: isHandlersDisabled
    }), onSVGMouseMove = _p.onSVGMouseMove, onSVGMouseOut = _p.onSVGMouseOut, verticalMarkerLeft = _p.verticalMarkerLeft;
    // There are multiple ways to indicate what X is selected.
    // TODO: make a uniform verticalMarkerX state to fit all use-cases.
    var highlightedX = useMemo(function () {
        var _a, _b, _c, _d;
        if (highlightedGroupIndex !== null) {
            return barGroups[highlightedGroupIndex].x;
        }
        if (verticalMarkerLeft !== null) {
            for (var _i = 0, scaledSeries_1 = scaledSeries; _i < scaledSeries_1.length; _i++) {
                var series_1 = scaledSeries_1[_i];
                if (series_1.x === verticalMarkerLeft) {
                    return (_b = (_a = series_1.datum) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : null;
                }
            }
        }
        if (highlightedPoint !== null) {
            return (_d = (_c = highlightedPoint === null || highlightedPoint === void 0 ? void 0 : highlightedPoint.datum) === null || _c === void 0 ? void 0 : _c.x) !== null && _d !== void 0 ? _d : null;
        }
        return null;
    }, [highlightedPoint, verticalMarkerLeft, highlightedGroupIndex, scaledSeries, barGroups]);
    var onPopoverDismiss = function (outsideClick) {
        dismissPopover();
        if (!outsideClick) {
            // The delay is needed to bypass focus events caused by click or keypress needed to unpin the popover.
            setTimeout(function () {
                var _a, _b;
                if (highlightedPoint || highlightedGroupIndex !== null) {
                    (_a = plotRef.current) === null || _a === void 0 ? void 0 : _a.focusApplication();
                }
                else {
                    (_b = plotRef.current) === null || _b === void 0 ? void 0 : _b.focusPlot();
                }
            }, 0);
        }
    };
    useLayoutEffect(function () {
        if (highlightedX !== null) {
            showPopover();
        }
    }, [highlightedX, showPopover]);
    var onSVGMouseDown = function () {
        if (isPopoverOpen) {
            if (isPopoverPinned) {
                dismissPopover();
            }
            else {
                pinPopover();
            }
        }
        else {
            showPopover();
        }
    };
    var onSVGFocus = function (event, trigger) {
        setPlotFocused(true);
        if (trigger === 'keyboard') {
            handlers.onFocus();
        }
        else {
            // noop: clicks are handled separately
        }
    };
    var onSVGBlur = function (event) {
        var _a;
        setPlotFocused(false);
        var blurTarget = event.relatedTarget || event.target;
        if (blurTarget === null ||
            !(blurTarget instanceof Element) ||
            !nodeContains(containerRefObject.current, blurTarget)) {
            setHighlightedPoint(null);
            if (!((_a = plotContainerRef === null || plotContainerRef === void 0 ? void 0 : plotContainerRef.current) === null || _a === void 0 ? void 0 : _a.contains(blurTarget))) {
                clearHighlightedSeries();
            }
            if (isPopoverOpen && !isPopoverPinned) {
                dismissPopover();
            }
        }
    };
    var onSVGKeyDown = handlers.onKeyDown;
    var xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;
    var verticalLineX = null;
    if (verticalMarkerLeft !== null) {
        verticalLineX = verticalMarkerLeft;
    }
    else if (isGroupNavigation && highlightedGroupIndex !== null) {
        var x_1 = (_b = xScale.d3Scale(barGroups[highlightedGroupIndex].x)) !== null && _b !== void 0 ? _b : null;
        if (x_1 !== null) {
            verticalLineX = xOffset + x_1;
        }
    }
    var point = useMemo(function () {
        return highlightedPoint
            ? {
                key: "".concat(highlightedPoint.x, "-").concat(highlightedPoint.y),
                x: highlightedPoint.x,
                y: highlightedPoint.y,
                color: highlightedPoint.color
            }
            : null;
    }, [highlightedPoint]);
    var verticalMarkers = useMemo(function () {
        return verticalLineX !== null
            ? scaledSeries
                .filter(function (_a) {
                var x = _a.x;
                return x === verticalLineX || isNaN(x);
            })
                .map(function (_a, index) {
                var x = _a.x, y = _a.y, color = _a.color;
                return ({
                    key: "".concat(index, "-").concat(x, "-").concat(y),
                    x: !horizontalBars ? verticalLineX || 0 : y,
                    y: !horizontalBars ? y : verticalLineX || 0,
                    color: color
                });
            })
            : [];
    }, [scaledSeries, verticalLineX, horizontalBars]);
    var popoverTrackRef = isGroupNavigation
        ? highlightedGroupRef
        : highlightedPoint
            ? highlightedPointRef
            : verticalMarkerRef;
    var highlightDetails = useMemo(function () {
        if (highlightedX === null) {
            return null;
        }
        // If there is a highlighted point - only use its corresponding series details.
        for (var _i = 0, visibleSeries_1 = visibleSeries; _i < visibleSeries_1.length; _i++) {
            var series_2 = visibleSeries_1[_i];
            if (series_2.series === (highlightedPoint === null || highlightedPoint === void 0 ? void 0 : highlightedPoint.series)) {
                return formatHighlighted(highlightedX, [series_2], xTickFormatter);
            }
        }
        // Otherwise - use all series details.
        return formatHighlighted(highlightedX, visibleSeries, xTickFormatter);
    }, [highlightedX, highlightedPoint, visibleSeries, xTickFormatter]);
    var activeAriaLabel = useMemo(function () {
        return highlightDetails
            ? "".concat(highlightDetails.position, ", ").concat(highlightDetails.details.map(function (d) { return d.key + ' ' + d.value; }).join(','))
            : '';
    }, [highlightDetails]);
    // Live region is used when nothing is focused e.g. when hovering.
    var activeLiveRegion = activeAriaLabel && !highlightedPoint && highlightedGroupIndex === null ? activeAriaLabel : '';
    return (React.createElement("div", { className: styles['chart-container'], ref: containerRef },
        React.createElement(AxisLabel, { axis: y, position: "left", title: xy.title[y] }),
        React.createElement("div", { className: styles['chart-container__horizontal'] },
            React.createElement(LabelsMeasure, { ticks: xy.ticks[y], scale: xy.scale[y], tickFormatter: xy.tickFormatter[y], autoWidth: setLeftLabelsWidth }),
            React.createElement("div", { className: styles['chart-container__vertical'] },
                React.createElement(ChartPlot, { ref: plotRef, width: plotWidth, height: plotHeight, offsetBottom: bottomLabelsHeight, isClickable: isPopoverOpen && !isPopoverPinned, ariaLabel: ariaLabel, ariaLabelledby: ariaLabelledby, ariaDescription: ariaDescription, ariaRoleDescription: i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.chartAriaRoleDescription, ariaLiveRegion: activeLiveRegion, activeElementRef: isGroupNavigation ? highlightedGroupRef : highlightedPointRef, activeElementKey: isPlotFocused && ((highlightedGroupIndex === null || highlightedGroupIndex === void 0 ? void 0 : highlightedGroupIndex.toString()) || (point === null || point === void 0 ? void 0 : point.key)), activeElementFocusOffset: isGroupNavigation ? 0 : 3, onMouseMove: onSVGMouseMove, onMouseOut: onSVGMouseOut, onMouseDown: onSVGMouseDown, onFocus: onSVGFocus, onBlur: onSVGBlur, onKeyDown: onSVGKeyDown },
                    React.createElement(LeftLabels, { axis: y, ticks: xy.ticks[y], scale: xy.scale[y], tickFormatter: xy.tickFormatter[y], title: xy.title[y], ariaRoleDescription: xy.ariaRoleDescription[y], width: plotWidth, height: plotHeight }),
                    horizontalBars && React.createElement(VerticalGridLines, { scale: yScale, ticks: yTicks, height: plotHeight }),
                    emphasizeBaselineAxis && linesOnly && (React.createElement(EmphasizedBaseline, { axis: x, scale: yScale, width: plotWidth, height: plotHeight })),
                    React.createElement(DataSeries, { axis: x, plotWidth: plotWidth, plotHeight: plotHeight, highlightedSeries: highlightedSeries !== null && highlightedSeries !== void 0 ? highlightedSeries : null, highlightedGroupIndex: highlightedGroupIndex, stackedBars: stackedBars, isGroupNavigation: isGroupNavigation, visibleSeries: visibleSeries, xScale: xScale, yScale: yScale }),
                    emphasizeBaselineAxis && !linesOnly && (React.createElement(EmphasizedBaseline, { axis: x, scale: yScale, width: plotWidth, height: plotHeight })),
                    React.createElement(VerticalMarker, { key: verticalLineX || '', height: plotHeight, showPoints: highlightedPoint === null, showLine: !isGroupNavigation, points: verticalMarkers, ref: verticalMarkerRef }),
                    highlightedPoint && (React.createElement(HighlightedPoint, { ref: highlightedPointRef, point: point, role: "button", ariaLabel: activeAriaLabel, ariaHasPopup: true, ariaExpanded: isPopoverPinned })),
                    isGroupNavigation && xScale.isCategorical() && (React.createElement(BarGroups, { ariaLabel: activeAriaLabel, isRefresh: isRefresh, isPopoverPinned: isPopoverPinned, barGroups: barGroups, highlightedGroupIndex: highlightedGroupIndex, highlightedGroupRef: highlightedGroupRef })),
                    React.createElement(BottomLabels, { axis: x, ticks: xy.ticks[x], scale: xy.scale[x], tickFormatter: xy.tickFormatter[x], title: xy.title[x], ariaRoleDescription: xy.ariaRoleDescription[x], height: plotHeight, width: plotWidth, offsetLeft: leftLabelsWidth + BOTTOM_LABELS_OFFSET, offsetRight: BOTTOM_LABELS_OFFSET, autoHeight: setBottomLabelsHeight })),
                React.createElement(AxisLabel, { axis: x, position: "bottom", title: xy.title[x] })),
            React.createElement(ChartPopover, { containerRef: containerRefObject, trackRef: popoverTrackRef, isOpen: isPopoverOpen, isPinned: isPopoverPinned, highlightDetails: highlightDetails, onDismiss: onPopoverDismiss, size: detailPopoverSize, dismissAriaLabel: i18nStrings.detailPopoverDismissAriaLabel }))));
}
//# sourceMappingURL=chart-container.js.map