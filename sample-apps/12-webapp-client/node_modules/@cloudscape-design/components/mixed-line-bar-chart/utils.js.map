{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/mixed-line-bar-chart/utils.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { ChartSeriesMarkerType } from '../internal/components/chart-series-marker';\nimport { ChartDataTypes, InternalChartSeries, MixedLineBarChartProps, ScaleType } from './interfaces';\nimport { ScaledBarGroup } from './make-scaled-bar-groups';\n\nexport const chartLegendMap: Record<string, ChartSeriesMarkerType> = {\n  line: 'line',\n  bar: 'rectangle',\n  threshold: 'dashed',\n};\n\nexport function computeDomainX<T>(series: readonly InternalChartSeries<T>[], xScaleType: ScaleType) {\n  if (xScaleType === 'categorical') {\n    return series.reduce((acc, s) => {\n      if (s.series.type !== 'threshold') {\n        s.series.data.forEach(({ x }) => {\n          if (acc.indexOf(x) === -1) {\n            acc.push(x);\n          }\n        });\n      }\n      return acc;\n    }, [] as T[]);\n  }\n\n  return series.reduce((acc, curr) => {\n    if (curr.series.type === 'threshold') {\n      return acc;\n    }\n\n    return curr.series.data.reduce(([min, max], { x }) => {\n      const newMin = min === undefined || x < min ? x : min;\n      const newMax = max === undefined || max < x ? x : max;\n      return [newMin, newMax] as T[];\n    }, acc);\n  }, [] as T[]);\n}\n\nfunction find<Q>(arr: readonly Q[], func: (el: Q) => boolean) {\n  for (let i = 0; i < arr.length; i++) {\n    const found = func(arr[i]);\n    if (found) {\n      return arr[i];\n    }\n  }\n  return null;\n}\n\nexport function computeDomainY<T>(\n  series: readonly InternalChartSeries<T>[],\n  scaleType: 'linear' | 'log',\n  stackedBars: boolean\n) {\n  let _series = series;\n\n  // For stacked bars, we need to accumulate all the bar series into a positive and a negative series\n  if (stackedBars) {\n    const { positiveData, negativeData } = series.reduce(\n      (acc, curr) => {\n        if (curr.series.type === 'bar') {\n          curr.series.data.forEach(({ x, y }) => {\n            const data = y < 0 ? acc.negativeData : acc.positiveData;\n            const stackedDatum = find(data, el => matchesX(el.x, x));\n            if (stackedDatum) {\n              stackedDatum.y += y;\n            } else {\n              data.push({ x, y });\n            }\n            return acc;\n          });\n        }\n        return acc;\n      },\n      {\n        positiveData: [] as MixedLineBarChartProps.Datum<T>[],\n        negativeData: [] as MixedLineBarChartProps.Datum<T>[],\n      }\n    );\n\n    // Artificial series with the sum of all bars when stacked\n    const stackedSeries: InternalChartSeries<T>[] = [\n      {\n        color: '',\n        index: NaN,\n        series: {\n          type: 'bar',\n          title: 'positive',\n          data: positiveData as any,\n        },\n      },\n      {\n        color: '',\n        index: NaN,\n        series: {\n          type: 'bar',\n          title: 'negative',\n          data: negativeData as any,\n        },\n      },\n    ];\n\n    // MixedLineBarChart can also contain other non-bar series,\n    // so we replace all bars with the artificial bar series\n    // Then proceed to compute range with it and the remaining (non-bar) series\n    _series = [...stackedSeries, ..._series.filter(s => s.series.type !== 'bar')];\n  }\n\n  const domain = _series.reduce(\n    (acc, curr) => {\n      if (curr.series.type === 'threshold') {\n        const [min, max] = acc;\n        const y = curr.series.y;\n        const newMin = min === undefined || y < min ? y : min;\n        const newMax = max === undefined || max < y ? y : max;\n        return [newMin, newMax];\n      }\n\n      return curr.series.data.reduce(([min, max], { y }) => {\n        const newMin = min === undefined || y < min ? y : min;\n        const newMax = max === undefined || max < y ? y : max;\n        return [newMin, newMax];\n      }, acc);\n    },\n    [0, 0]\n  );\n\n  // Log scales can't start from 0, so if possible, start from 1.\n  if (scaleType === 'log' && domain[0] === 0 && domain[1] > 1) {\n    return [1, domain[1]];\n  }\n  return domain;\n}\n\n// Starting from the given index, find the first x value in the x domain that has bar data attached to it.\nexport const nextValidDomainIndex = <T>(nextGroupIndex: number, barGroups: ScaledBarGroup<T>[], direction = 1) => {\n  let index = nextGroupIndex;\n\n  if (index < 0 || index >= barGroups.length) {\n    index = 0;\n  }\n\n  do {\n    if (barGroups[index].isValid && barGroups[index].hasData) {\n      return index;\n    }\n    index += direction;\n\n    // Loop back to the beginning if necessary\n    if (index >= barGroups.length) {\n      index = 0;\n    } else if (index < 0) {\n      index = barGroups.length - 1;\n    }\n  } while (index !== nextGroupIndex);\n  return 0;\n};\n\n/**\n * Find the subset of series that are individually navigable with keyboard.\n * Lines and thresholds are navigated individually, while bar series are grouped as one.\n */\nexport function findNavigableSeries<T extends ChartDataTypes>(series: ReadonlyArray<InternalChartSeries<T>>) {\n  const navigableSeries: Array<MixedLineBarChartProps.ChartSeries<T>> = [];\n  let navigableBarSeriesIndex = -1;\n\n  series.forEach(internalSeries => {\n    if (internalSeries.series.type === 'bar') {\n      // Only include the first bar series because all bar series are handled as one\n      if (navigableBarSeriesIndex === -1) {\n        navigableBarSeriesIndex = navigableSeries.length;\n        navigableSeries.push(internalSeries.series);\n      }\n    } else {\n      navigableSeries.push(internalSeries.series);\n    }\n  });\n  return { navigableSeries, navigableBarSeriesIndex };\n}\n\n/**\n * Checks if two x values are equal.\n * With a special treat for Date values which need to be converted to numbers first.\n */\nexport const matchesX = <T>(x1: T, x2: T) => {\n  if (x1 instanceof Date && x2 instanceof Date) {\n    return x1.getTime() === x2.getTime();\n  }\n  return x1 === x2;\n};\n\nexport type OffsetMap = Record<string | number, number>;\n\nexport interface StackedOffsets {\n  positiveOffsets: OffsetMap;\n  negativeOffsets: OffsetMap;\n}\n\n/**\n * Calculates list of offset maps from all data by accumulating each value\n */\nexport function calculateOffsetMaps(\n  data: Array<readonly MixedLineBarChartProps.Datum<ChartDataTypes>[]>\n): StackedOffsets[] {\n  return data.reduce((acc, curr, idx) => {\n    // First series receives empty offsets map\n    if (idx === 0) {\n      acc.push({ positiveOffsets: {}, negativeOffsets: {} });\n    }\n    const lastMap = acc[idx];\n    const map: StackedOffsets = lastMap\n      ? { positiveOffsets: { ...lastMap.positiveOffsets }, negativeOffsets: { ...lastMap.negativeOffsets } }\n      : { positiveOffsets: {}, negativeOffsets: {} };\n\n    curr.forEach(({ x, y }) => {\n      const key = getKeyValue(x);\n      if (y < 0) {\n        const lastValue = lastMap?.negativeOffsets[key] || 0;\n        map.negativeOffsets[key] = lastValue + y;\n      } else {\n        const lastValue = lastMap?.positiveOffsets[key] || 0;\n        map.positiveOffsets[key] = lastValue + y;\n      }\n    });\n\n    // Ignore last value for map but still run it for logging\n    if (idx < data.length - 1) {\n      acc.push(map);\n    }\n\n    return acc;\n  }, [] as StackedOffsets[]);\n}\n\n/**\n * Returns string or number value for ChartDataTypes key\n */\nexport const getKeyValue = (key: ChartDataTypes) => (key instanceof Date ? key.getTime() : key);\n"]}