/**
 * Combine all line series into an array of scaled data points with the given scales.
 */
export default function makeScaledSeries(series, xScale, yScale) {
    var xOffset = xScale.isCategorical() ? Math.max(0, xScale.d3Scale.bandwidth() - 1) / 2 : 0;
    var scaleX = function (x) { return (xScale.d3Scale(x) || 0) + xOffset; };
    var scaleY = function (y) { return yScale.d3Scale(y) || 0; };
    var allScaledX = getAllScaledX(series, scaleX);
    // Support threshold-only setup.
    if (allScaledX.length === 0) {
        allScaledX.push(NaN);
    }
    return series.reduce(function (acc, _a) {
        var series = _a.series, color = _a.color;
        if (series.type === 'line') {
            for (var _i = 0, _b = series.data; _i < _b.length; _i++) {
                var datum = _b[_i];
                acc.push({ x: scaleX(datum.x), y: scaleY(datum.y), datum: datum, series: series, color: color });
            }
        }
        else if (series.type === 'threshold') {
            for (var _c = 0, allScaledX_1 = allScaledX; _c < allScaledX_1.length; _c++) {
                var x = allScaledX_1[_c];
                acc.push({ x: x, y: scaleY(series.y), series: series, color: color });
            }
        }
        return acc;
    }, []);
}
/**
 * Collect unique x values from all data series.
 */
function getAllScaledX(series, scaleX) {
    var addDataXSet = new Set();
    for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {
        var s = series_1[_i].series;
        if (s.type !== 'threshold') {
            for (var _a = 0, _b = s.data; _a < _b.length; _a++) {
                var d = _b[_a];
                addDataXSet.add(scaleX(d.x));
            }
        }
    }
    var allDataX = [];
    addDataXSet.forEach(function (x) { return allDataX.push(x); });
    return allDataX;
}
//# sourceMappingURL=make-scaled-series.js.map