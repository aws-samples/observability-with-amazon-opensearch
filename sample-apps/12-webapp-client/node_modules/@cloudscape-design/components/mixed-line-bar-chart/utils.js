import { __assign, __spreadArray } from "tslib";
export var chartLegendMap = {
    line: 'line',
    bar: 'rectangle',
    threshold: 'dashed'
};
export function computeDomainX(series, xScaleType) {
    if (xScaleType === 'categorical') {
        return series.reduce(function (acc, s) {
            if (s.series.type !== 'threshold') {
                s.series.data.forEach(function (_a) {
                    var x = _a.x;
                    if (acc.indexOf(x) === -1) {
                        acc.push(x);
                    }
                });
            }
            return acc;
        }, []);
    }
    return series.reduce(function (acc, curr) {
        if (curr.series.type === 'threshold') {
            return acc;
        }
        return curr.series.data.reduce(function (_a, _b) {
            var min = _a[0], max = _a[1];
            var x = _b.x;
            var newMin = min === undefined || x < min ? x : min;
            var newMax = max === undefined || max < x ? x : max;
            return [newMin, newMax];
        }, acc);
    }, []);
}
function find(arr, func) {
    for (var i = 0; i < arr.length; i++) {
        var found = func(arr[i]);
        if (found) {
            return arr[i];
        }
    }
    return null;
}
export function computeDomainY(series, scaleType, stackedBars) {
    var _series = series;
    // For stacked bars, we need to accumulate all the bar series into a positive and a negative series
    if (stackedBars) {
        var _a = series.reduce(function (acc, curr) {
            if (curr.series.type === 'bar') {
                curr.series.data.forEach(function (_a) {
                    var x = _a.x, y = _a.y;
                    var data = y < 0 ? acc.negativeData : acc.positiveData;
                    var stackedDatum = find(data, function (el) { return matchesX(el.x, x); });
                    if (stackedDatum) {
                        stackedDatum.y += y;
                    }
                    else {
                        data.push({ x: x, y: y });
                    }
                    return acc;
                });
            }
            return acc;
        }, {
            positiveData: [],
            negativeData: []
        }), positiveData = _a.positiveData, negativeData = _a.negativeData;
        // Artificial series with the sum of all bars when stacked
        var stackedSeries = [
            {
                color: '',
                index: NaN,
                series: {
                    type: 'bar',
                    title: 'positive',
                    data: positiveData
                }
            },
            {
                color: '',
                index: NaN,
                series: {
                    type: 'bar',
                    title: 'negative',
                    data: negativeData
                }
            },
        ];
        // MixedLineBarChart can also contain other non-bar series,
        // so we replace all bars with the artificial bar series
        // Then proceed to compute range with it and the remaining (non-bar) series
        _series = __spreadArray(__spreadArray([], stackedSeries, true), _series.filter(function (s) { return s.series.type !== 'bar'; }), true);
    }
    var domain = _series.reduce(function (acc, curr) {
        if (curr.series.type === 'threshold') {
            var min = acc[0], max = acc[1];
            var y = curr.series.y;
            var newMin = min === undefined || y < min ? y : min;
            var newMax = max === undefined || max < y ? y : max;
            return [newMin, newMax];
        }
        return curr.series.data.reduce(function (_a, _b) {
            var min = _a[0], max = _a[1];
            var y = _b.y;
            var newMin = min === undefined || y < min ? y : min;
            var newMax = max === undefined || max < y ? y : max;
            return [newMin, newMax];
        }, acc);
    }, [0, 0]);
    // Log scales can't start from 0, so if possible, start from 1.
    if (scaleType === 'log' && domain[0] === 0 && domain[1] > 1) {
        return [1, domain[1]];
    }
    return domain;
}
// Starting from the given index, find the first x value in the x domain that has bar data attached to it.
export var nextValidDomainIndex = function (nextGroupIndex, barGroups, direction) {
    if (direction === void 0) { direction = 1; }
    var index = nextGroupIndex;
    if (index < 0 || index >= barGroups.length) {
        index = 0;
    }
    do {
        if (barGroups[index].isValid && barGroups[index].hasData) {
            return index;
        }
        index += direction;
        // Loop back to the beginning if necessary
        if (index >= barGroups.length) {
            index = 0;
        }
        else if (index < 0) {
            index = barGroups.length - 1;
        }
    } while (index !== nextGroupIndex);
    return 0;
};
/**
 * Find the subset of series that are individually navigable with keyboard.
 * Lines and thresholds are navigated individually, while bar series are grouped as one.
 */
export function findNavigableSeries(series) {
    var navigableSeries = [];
    var navigableBarSeriesIndex = -1;
    series.forEach(function (internalSeries) {
        if (internalSeries.series.type === 'bar') {
            // Only include the first bar series because all bar series are handled as one
            if (navigableBarSeriesIndex === -1) {
                navigableBarSeriesIndex = navigableSeries.length;
                navigableSeries.push(internalSeries.series);
            }
        }
        else {
            navigableSeries.push(internalSeries.series);
        }
    });
    return { navigableSeries: navigableSeries, navigableBarSeriesIndex: navigableBarSeriesIndex };
}
/**
 * Checks if two x values are equal.
 * With a special treat for Date values which need to be converted to numbers first.
 */
export var matchesX = function (x1, x2) {
    if (x1 instanceof Date && x2 instanceof Date) {
        return x1.getTime() === x2.getTime();
    }
    return x1 === x2;
};
/**
 * Calculates list of offset maps from all data by accumulating each value
 */
export function calculateOffsetMaps(data) {
    return data.reduce(function (acc, curr, idx) {
        // First series receives empty offsets map
        if (idx === 0) {
            acc.push({ positiveOffsets: {}, negativeOffsets: {} });
        }
        var lastMap = acc[idx];
        var map = lastMap
            ? { positiveOffsets: __assign({}, lastMap.positiveOffsets), negativeOffsets: __assign({}, lastMap.negativeOffsets) }
            : { positiveOffsets: {}, negativeOffsets: {} };
        curr.forEach(function (_a) {
            var x = _a.x, y = _a.y;
            var key = getKeyValue(x);
            if (y < 0) {
                var lastValue = (lastMap === null || lastMap === void 0 ? void 0 : lastMap.negativeOffsets[key]) || 0;
                map.negativeOffsets[key] = lastValue + y;
            }
            else {
                var lastValue = (lastMap === null || lastMap === void 0 ? void 0 : lastMap.positiveOffsets[key]) || 0;
                map.positiveOffsets[key] = lastValue + y;
            }
        });
        // Ignore last value for map but still run it for logging
        if (idx < data.length - 1) {
            acc.push(map);
        }
        return acc;
    }, []);
}
/**
 * Returns string or number value for ChartDataTypes key
 */
export var getKeyValue = function (key) { return (key instanceof Date ? key.getTime() : key); };
//# sourceMappingURL=utils.js.map