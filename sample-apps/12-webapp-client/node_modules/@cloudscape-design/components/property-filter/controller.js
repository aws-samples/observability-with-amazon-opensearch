import { __spreadArray } from "tslib";
import { fireNonCancelableEvent } from '../internal/events';
export var getQueryActions = function (query, onChange, inputRef, preventFocus) {
    var tokens = query.tokens, operation = query.operation;
    var fireOnChange = function (tokens, operation) {
        return fireNonCancelableEvent(onChange, { tokens: tokens, operation: operation });
    };
    var setToken = function (index, newToken) {
        var newTokens = __spreadArray([], tokens, true);
        if (newTokens && index < newTokens.length) {
            newTokens[index] = newToken;
        }
        fireOnChange(newTokens, operation);
    };
    var removeToken = function (index) {
        var _a;
        var newTokens = tokens.filter(function (_, i) { return i !== index; });
        fireOnChange(newTokens, operation);
        preventFocus.current = true;
        (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    var removeAllTokens = function () {
        var _a;
        fireOnChange([], operation);
        preventFocus.current = true;
        (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    };
    var addToken = function (newToken) {
        var newTokens = __spreadArray([], tokens, true);
        newTokens.push(newToken);
        fireOnChange(newTokens, operation);
    };
    var setOperation = function (newOperation) {
        fireOnChange(tokens, newOperation);
    };
    return {
        setToken: setToken,
        removeToken: removeToken,
        removeAllTokens: removeAllTokens,
        addToken: addToken,
        setOperation: setOperation
    };
};
export var getAllowedOperators = function (property) {
    var _a;
    var operators = property.operators, defaultOperator = property.defaultOperator;
    var operatorOrder = ['=', '!=', ':', '!:', '>=', '<=', '<', '>'];
    var operatorSet = (_a = {}, _a[defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '='] = true, _a);
    operators === null || operators === void 0 ? void 0 : operators.forEach(function (op) { return (operatorSet[op] = true); });
    return operatorOrder.filter(function (op) { return operatorSet[op]; });
};
/*
 * parses the value of the filtering input to figure out the current step of entering the token:
 * - "property": means that a filter on a particular column is being added, with operator already finalized
 * - "operator": means that a filter on a particular column is being added, with operator not yet finalized
 * - "free-text": means that a "free text" token is being added
 */
export var parseText = function (filteringText, filteringProperties, disableFreeTextFiltering) {
    var negatedGlobalQuery = /^(!:|!)(.*)/.exec(filteringText);
    if (!disableFreeTextFiltering && negatedGlobalQuery) {
        return {
            step: 'free-text',
            operator: '!:',
            value: negatedGlobalQuery[2]
        };
    }
    var property = (filteringProperties === null || filteringProperties === void 0 ? void 0 : filteringProperties.reduce(function (acc, property) {
        if (filteringText.toLowerCase().indexOf(property.propertyLabel.toLowerCase()) === 0) {
            // find the longest property whose name matches the filtering text
            if (property.propertyLabel.length > acc.length) {
                acc.length = property.propertyLabel.length;
                acc.property = property;
            }
        }
        return acc;
    }, { length: 0 })).property;
    if (!property) {
        return {
            step: 'free-text',
            value: filteringText
        };
    }
    var allowedOps = getAllowedOperators(property);
    var textWithoutProperty = filteringText.substring(property.propertyLabel.length);
    var hasOperator = new RegExp("^(\\s*)(".concat(allowedOps.join('|'), ")(.*)")).exec(textWithoutProperty);
    if (hasOperator) {
        return {
            step: 'property',
            property: property,
            // regex above can't match anything but an operator in the second capturing group
            operator: hasOperator[2],
            value: hasOperator[3].charAt(0) === ' ' ? hasOperator[3].slice(1) : hasOperator[3]
        };
    }
    var opPrefixesMap = allowedOps.reduce(function (acc, op) {
        if (op.length > 1) {
            var substr = op.substring(0, 1);
            acc[substr] = true;
        }
        return acc;
    }, {});
    var opPrefixes = Object.keys(opPrefixesMap);
    var enteringOperator = new RegExp("^(\\s*)([".concat(opPrefixes.join(','), "])?$")).exec(textWithoutProperty);
    if (enteringOperator) {
        return { step: 'operator', property: property, operatorPrefix: enteringOperator[2] || '' };
    }
    return {
        step: 'free-text',
        value: filteringText
    };
};
export var getPropertyOptions = function (filteringProperty, filteringOptions) {
    return filteringOptions === null || filteringOptions === void 0 ? void 0 : filteringOptions.filter(function (option) { return option.propertyKey === filteringProperty.key; });
};
export var getAllValueSuggestions = function (filteringOptions, filteringProperties, operator, i18nStrings, customGroupsText) {
    if (operator === void 0) { operator = '='; }
    var defaultGroup = {
        label: i18nStrings.groupValuesText,
        options: []
    };
    var customGroups = {};
    filteringOptions === null || filteringOptions === void 0 ? void 0 : filteringOptions.forEach(function (filteringOption) {
        var property = getPropertyByKey(filteringProperties, filteringOption.propertyKey);
        // given option refers to a non-existent filtering property
        if (!property) {
            return;
        }
        // this option's filtering property does not support current operator
        if (getAllowedOperators(property).indexOf(operator) === -1) {
            return;
        }
        if (property.group && !customGroups[property.group]) {
            var label = (customGroupsText === null || customGroupsText === void 0 ? void 0 : customGroupsText.reduce(function (acc, customGroup) { return (customGroup.group === property.group ? customGroup.values : acc); }, '')) || '';
            customGroups[property.group] = {
                label: label,
                options: []
            };
        }
        var propertyGroup = property.group ? customGroups[property.group] : defaultGroup;
        propertyGroup.options.push({
            tokenValue: property.propertyLabel + (operator || '=') + filteringOption.value,
            label: filteringOption.value,
            __labelPrefix: property.propertyLabel + ' ' + (operator || '=')
        });
    });
    return __spreadArray([defaultGroup], Object.keys(customGroups).map(function (group) { return customGroups[group]; }), true);
};
export var getPropertyByKey = function (filteringProperties, key) {
    var propertyMap = filteringProperties.reduce(function (acc, property) {
        acc[property.key] = property;
        return acc;
    }, {});
    return propertyMap[key];
};
var filteringPropertyToAutosuggestOption = function (filteringProperty) { return ({
    value: filteringProperty.propertyLabel,
    keepOpenOnSelect: true
}); };
export function getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, filteringPropertyToOption) {
    var defaultGroup = {
        label: i18nStrings.groupPropertiesText,
        options: []
    };
    var customGroups = {};
    filteringProperties.forEach(function (filteringProperty) {
        var group = filteringProperty.group;
        var optionsGroup = defaultGroup;
        if (group) {
            if (!customGroups[group]) {
                var label = (customGroupsText === null || customGroupsText === void 0 ? void 0 : customGroupsText.reduce(function (acc, customGroup) { return (customGroup.group === group ? customGroup.properties : acc); }, '')) || '';
                customGroups[group] = { options: [], label: label };
            }
            optionsGroup = customGroups[group];
        }
        optionsGroup.options.push(filteringPropertyToOption(filteringProperty));
    });
    var defaultGroupArray = defaultGroup.options.length ? [defaultGroup] : [];
    var customGroupsArray = Object.keys(customGroups).map(function (groupKey) { return customGroups[groupKey]; });
    return __spreadArray(__spreadArray([], defaultGroupArray, true), customGroupsArray, true);
}
export var getAutosuggestOptions = function (parsedText, filteringOptions, filteringProperties, customGroupsText, i18nStrings) {
    switch (parsedText.step) {
        case 'property': {
            var _a = parsedText.property, propertyLabel_1 = _a.propertyLabel, groupValuesLabel = _a.groupValuesLabel;
            var options = getPropertyOptions(parsedText.property, filteringOptions);
            return {
                __filterText: parsedText.value,
                options: [
                    {
                        options: (options || []).map(function (_a) {
                            var value = _a.value;
                            return ({
                                tokenValue: propertyLabel_1 + parsedText.operator + value,
                                label: value,
                                __labelPrefix: propertyLabel_1 + ' ' + parsedText.operator
                            });
                        }),
                        label: groupValuesLabel
                    },
                ]
            };
        }
        case 'operator': {
            return {
                __filterText: parsedText.property.propertyLabel + ' ' + parsedText.operatorPrefix,
                options: __spreadArray(__spreadArray([], getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, filteringPropertyToAutosuggestOption), true), [
                    {
                        options: getAllowedOperators(parsedText.property).map(function (value) { return ({
                            value: parsedText.property.propertyLabel + ' ' + value + ' ',
                            label: parsedText.property.propertyLabel + ' ' + value,
                            description: operatorToDescription(value, i18nStrings),
                            keepOpenOnSelect: true
                        }); }),
                        label: i18nStrings.operatorsText
                    },
                ], false)
            };
        }
        case 'free-text': {
            var needsValueSuggestions = !!parsedText.value;
            var needsPropertySuggestions = !(parsedText.step === 'free-text' && parsedText.operator === '!:');
            return {
                __filterText: parsedText.value,
                options: __spreadArray(__spreadArray([], (needsPropertySuggestions
                    ? getPropertySuggestions(filteringProperties, customGroupsText, i18nStrings, filteringPropertyToAutosuggestOption)
                    : []), true), (needsValueSuggestions
                    ? getAllValueSuggestions(filteringOptions, filteringProperties, parsedText.operator, i18nStrings, customGroupsText)
                    : []), true)
            };
        }
    }
};
export var operatorToDescription = function (operator, i18nStrings) {
    var _a;
    var mapping = (_a = {},
        _a['<'] = i18nStrings.operatorLessText,
        _a['<='] = i18nStrings.operatorLessOrEqualText,
        _a['>'] = i18nStrings.operatorGreaterText,
        _a['>='] = i18nStrings.operatorGreaterOrEqualText,
        _a[':'] = i18nStrings.operatorContainsText,
        _a['!:'] = i18nStrings.operatorDoesNotContainText,
        _a['='] = i18nStrings.operatorEqualsText,
        _a['!='] = i18nStrings.operatorDoesNotEqualText,
        _a);
    return mapping[operator];
};
//# sourceMappingURL=controller.js.map